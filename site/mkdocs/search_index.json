{
    "docs": [
        {
            "location": "/", 
            "text": "Python Tutorial \nby MG\n\n\n\n\nPython\n is a widely used general-purpose, high-level programming language. Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than would be possible in languages such as C++ or Java.\nThe language provides constructs intended to enable clear programs on both a small and large scale.\n\n\n\n\nTable of contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Python. \n\n\n Get Started\n\n\nBasics\n\n\n\n\nIntroduction\n\n\nBasic Syntax: conditional, loop, function\n\n\nData Structure: number\n\n\nData Structure: string\n\n\nData Structure: collection (list, set, tuple, dictionary)\n\n\nData Structure: datetime\n\n\n\n\nClasses and Inheritance\n\n\n\n\nClasses and Objects\n\n\nConstructors\n\n\nInheritance\n\n\nDesign Patterns with Python\n\n\n\n\nGo Deeper\n\n\n\n\nFile System \n IO\n\n\nOperating System Programming\n\n\nNetworking Programming\n\n\nConcurrency and Parallelism Programming\n\n\nEvent Based Programming\n\n\nWeb Development\n\n\n\n\nSoftware Development\n\n\n\n\nLogging\n\n\nConfiguration\n\n\nCommand Line\n\n\nTesting\n\n\nIDE \n Debugging\n\n\nPackage Manager\n\n\nEnvironment\n\n\nModule\n\n\nProduction\n\n\n\n\nMiscellaneous\n\n\n\n\nBooks\n\n\nCourses\n\n\nVideos\n\n\nChallenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nVideos\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nwww.pythonchallenge.com\n\n\n\n\nExternal Links\n\n\n\n\nTop 10 Python Libraries Of 2015", 
            "title": "Home"
        }, 
        {
            "location": "/#python-tutorial-by-mg", 
            "text": "Python  is a widely used general-purpose, high-level programming language. Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than would be possible in languages such as C++ or Java.\nThe language provides constructs intended to enable clear programs on both a small and large scale.", 
            "title": "Python Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Python.    Get Started", 
            "title": "Table of contents"
        }, 
        {
            "location": "/#basics", 
            "text": "Introduction  Basic Syntax: conditional, loop, function  Data Structure: number  Data Structure: string  Data Structure: collection (list, set, tuple, dictionary)  Data Structure: datetime", 
            "title": "Basics"
        }, 
        {
            "location": "/#classes-and-inheritance", 
            "text": "Classes and Objects  Constructors  Inheritance  Design Patterns with Python", 
            "title": "Classes and Inheritance"
        }, 
        {
            "location": "/#go-deeper", 
            "text": "File System   IO  Operating System Programming  Networking Programming  Concurrency and Parallelism Programming  Event Based Programming  Web Development", 
            "title": "Go Deeper"
        }, 
        {
            "location": "/#software-development", 
            "text": "Logging  Configuration  Command Line  Testing  IDE   Debugging  Package Manager  Environment  Module  Production", 
            "title": "Software Development"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Books  Courses  Videos  Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#videos", 
            "text": "", 
            "title": "Videos"
        }, 
        {
            "location": "/#challenges", 
            "text": "www.pythonchallenge.com", 
            "title": "Challenges"
        }, 
        {
            "location": "/#external-links", 
            "text": "Top 10 Python Libraries Of 2015", 
            "title": "External Links"
        }, 
        {
            "location": "/get_started/", 
            "text": "Get Started\n\n\nWelcome! This tutorial details how to get started with Python.\n\n\nFor Windows\n\n\nAnaconda 4.3.0\n\n\n\n\n\n\nAnaconda is BSD licensed which gives you permission to use Anaconda commercially and for redistribution.\n\n\n\n1. Download the installer \n\n2. Optional: Verify data integrity with MD5 or SHA-256  \n\n3. Double-click the \n.exe\n file to install Anaconda and follow the instructions on the screen\n\n\n\n\n\n\n\nPython 3.6 version\n\n\n64-BIT INSTALLER\n\n\n\n\n\n\nPython 2.7 version\n\n\n64-BIT INSTALLER\n\n\n\n\n\n\n\n\n\n\nStep 2.\n Discover the Map\n\n\nhttps://docs.python.org/2/library/index.html\n\n\nFor CentOS\n\n\nDeveloper tools\n\n\n\n\n\n\nThe Development tools will allow you to build and compile software from source code. Tools for building RPMs are also included, as well as source code management tools like Git, SVN, and CVS.\n\n\n\n\n\n\nyum groupinstall \nDevelopment tools\n\nyum install zlib-devel\nyum install bzip2-devel\nyum install openssl-devel\nyum install ncurses-devel\nyum install sqlite-devel\n\n\n\n\n\n\n\n\nPython \n Anaconda\n\n\n\n\n\n\nAnaconda is BSD licensed which gives you permission to use Anaconda commercially and for redistribution.\n\n\n\n\n\n\ncd /opt\nwget --no-check-certificate https://www.python.org/ftp/python/2.7.6/Python-2.7.6.tar.xz\ntar xf Python-2.7.6.tar.xz\ncd Python-2.7.6\n./configure --prefix=/usr/local\nmake \n make altinstall\n## link\nln -s /usr/local/bin/python2.7 /usr/local/bin/python\n# final check\nwhich python\npython -V\n# install Anaconda\ncd ~/Downloads\nwget https://repo.continuum.io/archive/Anaconda-2.3.0-Linux-x86_64.sh\nbash ~/Downloads/Anaconda-2.3.0-Linux-x86_64.sh", 
            "title": "Get Started"
        }, 
        {
            "location": "/get_started/#get-started", 
            "text": "Welcome! This tutorial details how to get started with Python.", 
            "title": "Get Started"
        }, 
        {
            "location": "/get_started/#for-windows", 
            "text": "", 
            "title": "For Windows"
        }, 
        {
            "location": "/get_started/#anaconda-430", 
            "text": "Anaconda is BSD licensed which gives you permission to use Anaconda commercially and for redistribution.  \n1. Download the installer  \n2. Optional: Verify data integrity with MD5 or SHA-256   \n3. Double-click the  .exe  file to install Anaconda and follow the instructions on the screen", 
            "title": "Anaconda 4.3.0"
        }, 
        {
            "location": "/get_started/#for-centos", 
            "text": "", 
            "title": "For CentOS"
        }, 
        {
            "location": "/get_started/#developer-tools", 
            "text": "The Development tools will allow you to build and compile software from source code. Tools for building RPMs are also included, as well as source code management tools like Git, SVN, and CVS.    yum groupinstall  Development tools \nyum install zlib-devel\nyum install bzip2-devel\nyum install openssl-devel\nyum install ncurses-devel\nyum install sqlite-devel", 
            "title": "Developer tools"
        }, 
        {
            "location": "/get_started/#python-anaconda", 
            "text": "Anaconda is BSD licensed which gives you permission to use Anaconda commercially and for redistribution.    cd /opt\nwget --no-check-certificate https://www.python.org/ftp/python/2.7.6/Python-2.7.6.tar.xz\ntar xf Python-2.7.6.tar.xz\ncd Python-2.7.6\n./configure --prefix=/usr/local\nmake   make altinstall\n## link\nln -s /usr/local/bin/python2.7 /usr/local/bin/python\n# final check\nwhich python\npython -V\n# install Anaconda\ncd ~/Downloads\nwget https://repo.continuum.io/archive/Anaconda-2.3.0-Linux-x86_64.sh\nbash ~/Downloads/Anaconda-2.3.0-Linux-x86_64.sh", 
            "title": "Python &amp; Anaconda"
        }, 
        {
            "location": "/tutorials/", 
            "text": "Python Tutorial\n\n\nPython is a general-purpose interpreted, interactive, object-oriented, and high-level programming language. It was created by Guido van Rossum during 1985- 1990. Like Perl, Python source code is also available under the GNU General Public License (GPL). This tutorial gives enough understanding on Python programming language.\n\n\nPython is Interpreted\n\n\nPython is processed at runtime by the interpreter. You do not need to compile your program before executing it. This is similar to PERL and PHP.\n\n\nPython is Interactive\n\n\nYou can actually sit at a Python prompt and interact with the interpreter directly to write your programs.\n\n\nPython is Object-Oriented\n\n\nPython supports Object-Oriented style or technique of programming that encapsulates code within objects.\n\n\nPython is Beginner Friendly\n\n\nPython is a great language for the beginner-level programmers and supports the development of a wide range of applications from simple text processing to WWW browsers to games.\n\n\nAudience\n\n\nThis tutorial is designed for software programmers who need to learn Python programming language from scratch.", 
            "title": "Introduction"
        }, 
        {
            "location": "/tutorials/#python-tutorial", 
            "text": "Python is a general-purpose interpreted, interactive, object-oriented, and high-level programming language. It was created by Guido van Rossum during 1985- 1990. Like Perl, Python source code is also available under the GNU General Public License (GPL). This tutorial gives enough understanding on Python programming language.  Python is Interpreted  Python is processed at runtime by the interpreter. You do not need to compile your program before executing it. This is similar to PERL and PHP.  Python is Interactive  You can actually sit at a Python prompt and interact with the interpreter directly to write your programs.  Python is Object-Oriented  Python supports Object-Oriented style or technique of programming that encapsulates code within objects.  Python is Beginner Friendly  Python is a great language for the beginner-level programmers and supports the development of a wide range of applications from simple text processing to WWW browsers to games.", 
            "title": "Python Tutorial"
        }, 
        {
            "location": "/tutorials/#audience", 
            "text": "This tutorial is designed for software programmers who need to learn Python programming language from scratch.", 
            "title": "Audience"
        }, 
        {
            "location": "/basic_syntax/", 
            "text": "Print, print\n\n\nprint \nHello World\n\n\n\n\n\nConditional\n\n\nif you_smart:\n    print \nlearn python\n\nelse:\n    print \ngo away\n\n\n\n\n\nLoop\n\n\nIn general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on. There may be a situation when you need to execute a block of code several number of times.\n\n\nProgramming languages provide various control structures that allow for more complicated execution paths. A loop statement allows us to execute a statement or group of statements multiple times. The following diagram illustrates a loop statement\n\n\n\n\n\n\n\n\n\nPython programming language provides following types of loops to handle looping requirements.\n\n\n\n\n\n\n\n\nwhile loop\n\n\nRepeats a statement or group of statements while a given condition is TRUE. It tests the condition before executing the loop body.\n\n\n\n\n\n\nfor loop\n\n\nExecutes a sequence of statements multiple times and abbreviates the code that manages the loop variable.\n\n\n\n\n\n\nnested loops\n\n\nYou can use one or more loop inside any another while, for or do..while loop.\n\n\n\n\n\n\n\n\n\nWhile Loop\n\n\nA while loop statement in Python programming language repeatedly executes a target statement as long as a given condition is true.\n\n\nSyntax\n\n\nThe syntax of a while loop in Python programming language is\n\n\nwhile expression:\n   statement(s)\n\n\n\n\nExample\n\n\ncount = 0\nwhile count \n 9:\n   print 'The count is:', count\n   count += 1\n\nprint \nGood bye!\n\n\n\n\n\nFor Loop\n\n\nIt has the ability to iterate over the items of any sequence, such as a list or a string.\n\n\nSyntax\n\n\nfor iterating_var in sequence:\n   statements(s)\n\n\n\n\nIf a sequence contains an expression list, it is evaluated first. Then, the first item in the sequence is assigned to the iterating variable iterating_var. Next, the statements block is executed. Each item in the list is assigned to iterating_var, and the statement(s) block is executed until the entire sequence is exhausted.\n\n\nExample\n\n\nfor i in range(10):\n    print \nhello\n, i\n\nfor letter in 'Python':\n   print 'Current letter :', letter\n\nfruits = ['banana', 'apple',  'mango']\nfor fruit in fruits:\n   print 'Current fruit :', fruit\n\nprint \nGood bye!\n\n\n\n\n\nYield and Generator\n\n\nYield is a keyword that is used like return, except the function will return a generator.\n\n\ndef createGenerator():\n    yield 1\n    yield 2\n    yield 3\n\nmygenerator = createGenerator() # create a generator\nprint(mygenerator) # mygenerator is an object!\n# \ngenerator object createGenerator at 0xb7555c34\n\nfor i in mygenerator:\n    print(i)\n# 1\n# 2\n# 3\n\n\n\n\nVisit \nYield and Generator explained\n for more information\n\n\nFunctions\n\n\nVariable-length arguments\n\n\ndef functionname([formal_args,] *var_args_tuple ):\n   \nfunction_docstring\n\n   function_suite\n   return [expression]\n\n\n\n\nExample\n\n\n#!/usr/bin/python\n\n# Function definition is here\ndef printinfo( arg1, *vartuple ):\n   \nThis prints a variable passed arguments\n\n   print \nOutput is: \n\n   print arg1\n   for var in vartuple:\n      print var\n   return;\n\n# Now you can call printinfo function\nprintinfo( 10 )\nprintinfo( 70, 60, 50 )\n\n\n\n\n\nCoding Convention\n\n\nCode layout\n\n\nIndentation: 4 spaces\n\n\nSuggest Readings\n\n\n\n\n\"Python Functions\". www.tutorialspoint.com\n\n\n\"Python Loops\". www.tutorialspoint.com\n\n\n\"What does the \u201cyield\u201d keyword do?\". stackoverflow.com\n\n\n\"Improve Your Python: 'yield' and Generators Explained\". jeffknupp.com", 
            "title": "Overview"
        }, 
        {
            "location": "/basic_syntax/#print-print", 
            "text": "print  Hello World", 
            "title": "Print, print"
        }, 
        {
            "location": "/basic_syntax/#conditional", 
            "text": "if you_smart:\n    print  learn python \nelse:\n    print  go away", 
            "title": "Conditional"
        }, 
        {
            "location": "/basic_syntax/#loop", 
            "text": "In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on. There may be a situation when you need to execute a block of code several number of times.  Programming languages provide various control structures that allow for more complicated execution paths. A loop statement allows us to execute a statement or group of statements multiple times. The following diagram illustrates a loop statement     Python programming language provides following types of loops to handle looping requirements.     while loop  Repeats a statement or group of statements while a given condition is TRUE. It tests the condition before executing the loop body.    for loop  Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.    nested loops  You can use one or more loop inside any another while, for or do..while loop.", 
            "title": "Loop"
        }, 
        {
            "location": "/basic_syntax/#while-loop", 
            "text": "A while loop statement in Python programming language repeatedly executes a target statement as long as a given condition is true.  Syntax  The syntax of a while loop in Python programming language is  while expression:\n   statement(s)  Example  count = 0\nwhile count   9:\n   print 'The count is:', count\n   count += 1\n\nprint  Good bye!", 
            "title": "While Loop"
        }, 
        {
            "location": "/basic_syntax/#for-loop", 
            "text": "It has the ability to iterate over the items of any sequence, such as a list or a string.  Syntax  for iterating_var in sequence:\n   statements(s)  If a sequence contains an expression list, it is evaluated first. Then, the first item in the sequence is assigned to the iterating variable iterating_var. Next, the statements block is executed. Each item in the list is assigned to iterating_var, and the statement(s) block is executed until the entire sequence is exhausted.  Example  for i in range(10):\n    print  hello , i\n\nfor letter in 'Python':\n   print 'Current letter :', letter\n\nfruits = ['banana', 'apple',  'mango']\nfor fruit in fruits:\n   print 'Current fruit :', fruit\n\nprint  Good bye!", 
            "title": "For Loop"
        }, 
        {
            "location": "/basic_syntax/#yield-and-generator", 
            "text": "Yield is a keyword that is used like return, except the function will return a generator.  def createGenerator():\n    yield 1\n    yield 2\n    yield 3\n\nmygenerator = createGenerator() # create a generator\nprint(mygenerator) # mygenerator is an object!\n#  generator object createGenerator at 0xb7555c34 \nfor i in mygenerator:\n    print(i)\n# 1\n# 2\n# 3  Visit  Yield and Generator explained  for more information", 
            "title": "Yield and Generator"
        }, 
        {
            "location": "/basic_syntax/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/basic_syntax/#variable-length-arguments", 
            "text": "def functionname([formal_args,] *var_args_tuple ):\n    function_docstring \n   function_suite\n   return [expression]  Example  #!/usr/bin/python\n\n# Function definition is here\ndef printinfo( arg1, *vartuple ):\n    This prints a variable passed arguments \n   print  Output is:  \n   print arg1\n   for var in vartuple:\n      print var\n   return;\n\n# Now you can call printinfo function\nprintinfo( 10 )\nprintinfo( 70, 60, 50 )", 
            "title": "Variable-length arguments"
        }, 
        {
            "location": "/basic_syntax/#coding-convention", 
            "text": "", 
            "title": "Coding Convention"
        }, 
        {
            "location": "/basic_syntax/#code-layout", 
            "text": "Indentation: 4 spaces", 
            "title": "Code layout"
        }, 
        {
            "location": "/basic_syntax/#suggest-readings", 
            "text": "\"Python Functions\". www.tutorialspoint.com  \"Python Loops\". www.tutorialspoint.com  \"What does the \u201cyield\u201d keyword do?\". stackoverflow.com  \"Improve Your Python: 'yield' and Generators Explained\". jeffknupp.com", 
            "title": "Suggest Readings"
        }, 
        {
            "location": "/basic_syntax_yield/", 
            "text": "Yield and Generators\n\n\nCoroutines and Subroutines\n\n\nWhen we call a normal Python function, execution starts at function's first line and continues until a return statement, exception, or the end of the function (which is seen as an implicit return None) is encountered. Once a function returns control to its caller, that's it. Any work done by the function and stored in local variables is lost. A new call to the function creates everything from scratch.\n\n\nThis is all very standard when discussing functions (more generally referred to as subroutines) in computer programming. There are times, though, when it's beneficial to have the ability to create a \"function\" which, instead of simply returning a single value, is able to yield a series of values. To do so, such a function would need to be able to \"save its work,\" so to speak.\n\n\nI said, \"yield a series of values\" because our hypothetical function doesn't \"return\" in the normal sense. return implies that the function is returning control of execution to the point where the function was called. \"Yield,\" however, implies that the transfer of control is temporary and voluntary, and our function expects to regain it in the future.\n\n\nIn Python, \"functions\" with these capabilities are called generators, and they're incredibly useful. generators (and the yield statement) were initially introduced to give programmers a more straightforward way to write code responsible for producing a series of values. Previously, creating something like a random number generator required a class or module that both generated values and kept track of state between calls. With the introduction of generators, this became much simpler.\n\n\nTo better understand the problem generators solve, let's take a look at an example. Throughout the example, keep in mind the core problem being solved: generating a series of values.\n\n\nNote: Outside of Python, all but the simplest generators would be referred to as coroutines. I'll use the latter term later in the post. The important thing to remember is, in Python, everything described here as a coroutine is still a generator. Python formally defines the term generator; coroutine is used in discussion but has no formal definition in the language.\n\n\nExample: Fun With Prime Numbers\n\n\nSuppose our boss asks us to write a function that takes a list of ints and returns some Iterable containing the elements which are prime1 numbers.\n\n\nRemember, an Iterable is just an object capable of returning its members one at a time.\n\n\n\"Simple,\" we say, and we write the following:\n\n\ndef get_primes(input_list):\n    result_list = list()\n    for element in input_list:\n        if is_prime(element):\n            result_list.append()\n\n    return result_list\n\n\n\n\nor better yet...\n\n\ndef get_primes(input_list):\n    return (element for element in input_list if is_prime(element))\n\n# not germane to the example, but here's a possible implementation of\n# is_prime...\n\ndef is_prime(number):\n    if number \n 1:\n        if number == 2:\n            return True\n        if number % 2 == 0:\n            return False\n        for current in range(3, int(math.sqrt(number) + 1), 2):\n            if number % current == 0:\n                return False\n        return True\n    return False\n\n\n\n\nEither get_primes implementation above fulfills the requirements, so we tell our boss we're done. She reports our function works and is exactly what she wanted.\n\n\nDealing With Infinite Sequences\n\n\nWell, not quite exactly. A few days later, our boss comes back and tells us she's run into a small problem: she wants to use our get_primes function on a very large list of numbers. In fact, the list is so large that merely creating it would consume all of the system's memory. To work around this, she wants to be able to call get_primes with a start value and get all the primes larger than start (perhaps she's solving Project Euler problem 10).\n\n\nOnce we think about this new requirement, it becomes clear that it requires more than a simple change to get_primes. Clearly, we can't return a list of all the prime numbers from start to infinity (operating on infinite sequences, though, has a wide range of useful applications). The chances of solving this problem using a normal function seem bleak.\n\n\nBefore we give up, let's determine the core obstacle preventing us from writing a function that satisfies our boss's new requirements. Thinking about it, we arrive at the following: functions only get one chance to return results, and thus must return all results at once. It seems pointless to make such an obvious statement; \"functions just work that way,\" we think. The real value lies in asking, \"but what if they didn't?\"\n\n\nImagine what we could do if get_primes could simply return the next value instead of all the values at once. It wouldn't need to create a list at all. No list, no memory issues. Since our boss told us she's just iterating over the results, she wouldn't know the difference.\n\n\nUnfortunately, this doesn't seem possible. Even if we had a magical function that allowed us to iterate from n to infinity, we'd get stuck after returning the first value:\n\n\ndef get_primes(start):\n    for element in magical_infinite_range(start):\n        if is_prime(element):\n            return element\n\n\n\n\nImagine get_primes is called like so:\n\n\ndef solve_number_10():\n    # She *is* working on Project Euler #10, I knew it!\n    total = 2\n    for next_prime in get_primes(3):\n        if next_prime \n 2000000:\n            total += next_prime\n        else:\n            print(total)\n            return\n\n\n\n\nClearly, in get_primes, we would immediately hit the case where number = 3 and return at line 4. Instead of return, we need a way to generate a value and, when asked for the next one, pick up where we left off.\n\n\nFunctions, though, can't do this. When they return, they're done for good. Even if we could guarantee a function would be called again, we have no way of saying, \"OK, now, instead of starting at the first line like we normally do, start up where we left off at line 4.\" Functions have a single entry point: the first line.\n\n\nEnter the Generator\n\n\nThis sort of problem is so common that a new construct was added to Python to solve it: the generator. A generator \"generates\" values. Creating generators was made as straightforward as possible through the concept of generator functions, introduced simultaneously.\n\n\nA generator function is defined like a normal function, but whenever it needs to generate a value, it does so with the yield keyword rather than return. If the body of a def contains yield, the function automatically becomes a generator function (even if it also contains a return statement). There's nothing else we need to do to create one.\n\n\ngenerator functions create generator iterators. That's the last time you'll see the term generator iterator, though, since they're almost always referred to as \"generators\". Just remember that a generator is a special type of iterator. To be considered an iterator, generators must define a few methods, one of which is \nnext\n(). To get the next value from a generator, we use the same built-in function as for iterators: next().\n\n\nThis point bears repeating: to get the next value from a generator, we use the same built-in function as for iterators: next().\n\n\n(next() takes care of calling the generator's \nnext\n() method). Since a generator is a type of iterator, it can be used in a for loop.\n\n\nSo whenever next() is called on a generator, the generator is responsible for passing back a value to whomever called next(). It does so by calling yield along with the value to be passed back (e.g. yield 7). The easiest way to remember what yield does is to think of it as return (plus a little magic) for generator functions.**\n\n\nAgain, this bears repeating: yield is just return (plus a little magic) for generator functions.\n\n\nHere's a simple generator function:\n\n\n def simple_generator_function():\n\n    yield 1\n\n    yield 2\n\n    yield 3\n\n\n\n\nAnd here are two simple ways to use it:\n\n\n for value in simple_generator_function():\n\n     print(value)\n1\n2\n3\n\n our_generator = simple_generator_function()\n\n next(our_generator)\n1\n\n next(our_generator)\n2\n\n next(our_generator)\n3\n\n\n\n\nMagic?\n\n\nWhat's the magic part? Glad you asked! When a generator function calls yield, the \"state\" of the generator function is frozen; the values of all variables are saved and the next line of code to be executed is recorded until next() is called again. Once it is, the generator function simply resumes where it left off. If next() is never called again, the state recorded during the yield call is (eventually) discarded.\n\n\nLet's rewrite get_primes as a generator function. Notice that we no longer need the magical_infinite_range function. Using a simple while loop, we can create our own infinite sequence:\n\n\ndef get_primes(number):\n    while True:\n        if is_prime(number):\n            yield number\n        number += 1\n\n\n\n\nIf a generator function calls return or reaches the end its definition, a StopIteration exception is raised. This signals to whoever was calling next() that the generator is exhausted (this is normal iterator behavior). It is also the reason the while True: loop is present in get_primes. If it weren't, the first time next() was called we would check if the number is prime and possibly yield it. If next() were called again, we would uselessly add 1 to number and hit the end of the generator function (causing StopIteration to be raised). Once a generator has been exhausted, calling next() on it will result in an error, so you can only consume all the values of a generator once. The following will not work:\n\n\n our_generator = simple_generator_function()\n\n for value in our_generator:\n\n     print(value)\n\n\n # our_generator has been exhausted...\n\n print(next(our_generator))\nTraceback (most recent call last):\n  File \nipython-input-13-7e48a609051a\n, line 1, in \nmodule\n\n    next(our_generator)\nStopIteration\n\n\n # however, we can always create a new generator\n\n # by calling the generator function again...\n\n\n new_generator = simple_generator_function()\n\n print(next(new_generator)) # perfectly valid\n1\n\n\n\n\nThus, the while loop is there to make sure we never reach the end of get_primes. It allows us to generate a value for as long as next() is called on the generator. This is a common idiom when dealing with infinite series (and generators in general).\n\n\nVisualizing the flow\n\n\nLet's go back to the code that was calling get_primes: solve_number_10.\n\n\ndef solve_number_10():\n    # She *is* working on Project Euler #10, I knew it!\n    total = 2\n    for next_prime in get_primes(3):\n        if next_prime \n 2000000:\n            total += next_prime\n        else:\n            print(total)\n            return\n\n\n\n\nIt's helpful to visualize how the first few elements are created when we call get_primes in solve_number_10's for loop. When the for loop requests the first value from get_primes, we enter get_primes as we would in a normal function.\n\n\n\n\nWe enter the while loop on line 3\n\n\nThe if condition holds (3 is prime)\n\n\nWe yield the value 3 and control to solve_number_10.\n\n\n\n\nThen, back in solve_number_10:\n\n\n\n\nThe value 3 is passed back to the for loop\n\n\nThe for loop assigns next_prime to this value\n\n\nnext_prime is added to total\n\n\nThe for loop requests the next element from get_primes\n\n\n\n\nThis time, though, instead of entering get_primes back at the top, we resume at line 5, where we left off.\n\n\ndef get_primes(number):\n    while True:\n        if is_prime(number):\n            yield number\n        number += 1 # \n\n\n\n\n\nMost importantly, number still has the same value it did when we called yield (i.e. 3). Remember, yield both passes a value to whoever called next(), and saves the \"state\" of the generator function. Clearly, then, number is incremented to 4, we hit the top of the while loop, and keep incrementing number until we hit the next prime number (5). Again we yield the value of number to the for loop in solve_number_10. This cycle continues until the for loop stops (at the first prime greater than 2,000,000).\n\n\nMoar Power\n\n\nIn PEP 342, support was added for passing values into generators. PEP 342 gave generators the power to yield a value (as before), receive a value, or both yield a value and receive a (possibly different) value in a single statement.\n\n\nTo illustrate how values are sent to a generator, let's return to our prime number example. This time, instead of simply printing every prime number greater than number, we'll find the smallest prime number greater than successive powers of a number (i.e. for 10, we want the smallest prime greater than 10, then 100, then 1000, etc.). We start in the same way as get_primes:\n\n\ndef print_successive_primes(iterations, base=10):\n    # like normal functions, a generator function\n    # can be assigned to a variable\n\n    prime_generator = get_primes(base)\n    # missing code...\n    for power in range(iterations):\n        # missing code...\n\ndef get_primes(number):\n    while True:\n        if is_prime(number):\n        # ... what goes here?\n\n\n\n\nThe next line of get_primes takes a bit of explanation. While yield number would yield the value of number, a statement of the form other = yield foo means, \"yield foo and, when a value is sent to me, set other to that value.\" You can \"send\" values to a generator using the generator's send method.\n\n\ndef get_primes(number):\n    while True:\n        if is_prime(number):\n            number = yield number\n        number += 1\n\n\n\n\nIn this way, we can set number to a different value each time the generator yields. We can now fill in the missing code in print_successive_primes:\n\n\ndef print_successive_primes(iterations, base=10):\n    prime_generator = get_primes(base)\n    prime_generator.send(None)\n    for power in range(iterations):\n        print(prime_generator.send(base ** power))\n\n\n\n\nTwo things to note here: First, we're printing the result of generator.send, which is possible because send both sends a value to the generator and returns the value yielded by the generator (mirroring how yield works from within the generator function).\n\n\nSecond, notice the prime_generator.send(None) line. When you're using send to \"start\" a generator (that is, execute the code from the first line of the generator function up to the first yield statement), you must send None. This makes sense, since by definition the generator hasn't gotten to the first yield statement yet, so if we sent a real value there would be nothing to \"receive\" it. Once the generator is started, we can send values as we do above.\n\n\nRound-up\n\n\nIn the second half of this series, we'll discuss the various ways in which generators have been enhanced and the power they gained as a result. yield has become one of the most powerful keywords in Python. Now that we've built a solid understanding of how yield works, we have the knowledge necessary to understand some of the more \"mind-bending\" things that yield can be used for.\n\n\nBelieve it or not, we've barely scratched the surface of the power of yield. For example, while send does work as described above, it's almost never used when generating simple sequences like our example. Below, I've pasted a small demonstration of one common way send is used. I'll not say any more about it as figuring out how and why it works will be a good warm-up for part two.\n\n\nimport random\n\ndef get_data():\n    \nReturn 3 random integers between 0 and 9\n\n    return random.sample(range(10), 3)\n\ndef consume():\n    \nDisplays a running average across lists of integers sent to it\n\n    running_sum = 0\n    data_items_seen = 0\n\n    while True:\n        data = yield\n        data_items_seen += len(data)\n        running_sum += sum(data)\n        print('The running average is {}'.format(running_sum / float(data_items_seen)))\n\ndef produce(consumer):\n    \nProduces a set of values and forwards them to the pre-defined consumer\n    function\n\n    while True:\n        data = get_data()\n        print('Produced {}'.format(data))\n        consumer.send(data)\n        yield\n\nif __name__ == '__main__':\n    consumer = consume()\n    consumer.send(None)\n    producer = produce(consumer)\n\n    for _ in range(10):\n        print('Producing...')\n        next(producer)\n\n\n\n\nRemember...\n\n\nThere are a few key ideas I hope you take away from this discussion:\n\n\n\n\ngenerators are used to generate a series of values\n\n\nyield is like the return of generator functions\n\n\nThe only other thing yield does is save the \"state\" of a generator function\n\n\nA generator is just a special type of iterator\n\n\nLike iterators, we can get the next value from a generator using next()\n\n\nfor gets values by calling next() implicitly", 
            "title": "Yield and Generator"
        }, 
        {
            "location": "/basic_syntax_yield/#yield-and-generators", 
            "text": "", 
            "title": "Yield and Generators"
        }, 
        {
            "location": "/basic_syntax_yield/#coroutines-and-subroutines", 
            "text": "When we call a normal Python function, execution starts at function's first line and continues until a return statement, exception, or the end of the function (which is seen as an implicit return None) is encountered. Once a function returns control to its caller, that's it. Any work done by the function and stored in local variables is lost. A new call to the function creates everything from scratch.  This is all very standard when discussing functions (more generally referred to as subroutines) in computer programming. There are times, though, when it's beneficial to have the ability to create a \"function\" which, instead of simply returning a single value, is able to yield a series of values. To do so, such a function would need to be able to \"save its work,\" so to speak.  I said, \"yield a series of values\" because our hypothetical function doesn't \"return\" in the normal sense. return implies that the function is returning control of execution to the point where the function was called. \"Yield,\" however, implies that the transfer of control is temporary and voluntary, and our function expects to regain it in the future.  In Python, \"functions\" with these capabilities are called generators, and they're incredibly useful. generators (and the yield statement) were initially introduced to give programmers a more straightforward way to write code responsible for producing a series of values. Previously, creating something like a random number generator required a class or module that both generated values and kept track of state between calls. With the introduction of generators, this became much simpler.  To better understand the problem generators solve, let's take a look at an example. Throughout the example, keep in mind the core problem being solved: generating a series of values.  Note: Outside of Python, all but the simplest generators would be referred to as coroutines. I'll use the latter term later in the post. The important thing to remember is, in Python, everything described here as a coroutine is still a generator. Python formally defines the term generator; coroutine is used in discussion but has no formal definition in the language.", 
            "title": "Coroutines and Subroutines"
        }, 
        {
            "location": "/basic_syntax_yield/#example-fun-with-prime-numbers", 
            "text": "Suppose our boss asks us to write a function that takes a list of ints and returns some Iterable containing the elements which are prime1 numbers.  Remember, an Iterable is just an object capable of returning its members one at a time.  \"Simple,\" we say, and we write the following:  def get_primes(input_list):\n    result_list = list()\n    for element in input_list:\n        if is_prime(element):\n            result_list.append()\n\n    return result_list  or better yet...  def get_primes(input_list):\n    return (element for element in input_list if is_prime(element))\n\n# not germane to the example, but here's a possible implementation of\n# is_prime...\n\ndef is_prime(number):\n    if number   1:\n        if number == 2:\n            return True\n        if number % 2 == 0:\n            return False\n        for current in range(3, int(math.sqrt(number) + 1), 2):\n            if number % current == 0:\n                return False\n        return True\n    return False  Either get_primes implementation above fulfills the requirements, so we tell our boss we're done. She reports our function works and is exactly what she wanted.", 
            "title": "Example: Fun With Prime Numbers"
        }, 
        {
            "location": "/basic_syntax_yield/#dealing-with-infinite-sequences", 
            "text": "Well, not quite exactly. A few days later, our boss comes back and tells us she's run into a small problem: she wants to use our get_primes function on a very large list of numbers. In fact, the list is so large that merely creating it would consume all of the system's memory. To work around this, she wants to be able to call get_primes with a start value and get all the primes larger than start (perhaps she's solving Project Euler problem 10).  Once we think about this new requirement, it becomes clear that it requires more than a simple change to get_primes. Clearly, we can't return a list of all the prime numbers from start to infinity (operating on infinite sequences, though, has a wide range of useful applications). The chances of solving this problem using a normal function seem bleak.  Before we give up, let's determine the core obstacle preventing us from writing a function that satisfies our boss's new requirements. Thinking about it, we arrive at the following: functions only get one chance to return results, and thus must return all results at once. It seems pointless to make such an obvious statement; \"functions just work that way,\" we think. The real value lies in asking, \"but what if they didn't?\"  Imagine what we could do if get_primes could simply return the next value instead of all the values at once. It wouldn't need to create a list at all. No list, no memory issues. Since our boss told us she's just iterating over the results, she wouldn't know the difference.  Unfortunately, this doesn't seem possible. Even if we had a magical function that allowed us to iterate from n to infinity, we'd get stuck after returning the first value:  def get_primes(start):\n    for element in magical_infinite_range(start):\n        if is_prime(element):\n            return element  Imagine get_primes is called like so:  def solve_number_10():\n    # She *is* working on Project Euler #10, I knew it!\n    total = 2\n    for next_prime in get_primes(3):\n        if next_prime   2000000:\n            total += next_prime\n        else:\n            print(total)\n            return  Clearly, in get_primes, we would immediately hit the case where number = 3 and return at line 4. Instead of return, we need a way to generate a value and, when asked for the next one, pick up where we left off.  Functions, though, can't do this. When they return, they're done for good. Even if we could guarantee a function would be called again, we have no way of saying, \"OK, now, instead of starting at the first line like we normally do, start up where we left off at line 4.\" Functions have a single entry point: the first line.", 
            "title": "Dealing With Infinite Sequences"
        }, 
        {
            "location": "/basic_syntax_yield/#enter-the-generator", 
            "text": "This sort of problem is so common that a new construct was added to Python to solve it: the generator. A generator \"generates\" values. Creating generators was made as straightforward as possible through the concept of generator functions, introduced simultaneously.  A generator function is defined like a normal function, but whenever it needs to generate a value, it does so with the yield keyword rather than return. If the body of a def contains yield, the function automatically becomes a generator function (even if it also contains a return statement). There's nothing else we need to do to create one.  generator functions create generator iterators. That's the last time you'll see the term generator iterator, though, since they're almost always referred to as \"generators\". Just remember that a generator is a special type of iterator. To be considered an iterator, generators must define a few methods, one of which is  next (). To get the next value from a generator, we use the same built-in function as for iterators: next().  This point bears repeating: to get the next value from a generator, we use the same built-in function as for iterators: next().  (next() takes care of calling the generator's  next () method). Since a generator is a type of iterator, it can be used in a for loop.  So whenever next() is called on a generator, the generator is responsible for passing back a value to whomever called next(). It does so by calling yield along with the value to be passed back (e.g. yield 7). The easiest way to remember what yield does is to think of it as return (plus a little magic) for generator functions.**  Again, this bears repeating: yield is just return (plus a little magic) for generator functions.  Here's a simple generator function:   def simple_generator_function():     yield 1     yield 2     yield 3  And here are two simple ways to use it:   for value in simple_generator_function():      print(value)\n1\n2\n3  our_generator = simple_generator_function()  next(our_generator)\n1  next(our_generator)\n2  next(our_generator)\n3", 
            "title": "Enter the Generator"
        }, 
        {
            "location": "/basic_syntax_yield/#magic", 
            "text": "What's the magic part? Glad you asked! When a generator function calls yield, the \"state\" of the generator function is frozen; the values of all variables are saved and the next line of code to be executed is recorded until next() is called again. Once it is, the generator function simply resumes where it left off. If next() is never called again, the state recorded during the yield call is (eventually) discarded.  Let's rewrite get_primes as a generator function. Notice that we no longer need the magical_infinite_range function. Using a simple while loop, we can create our own infinite sequence:  def get_primes(number):\n    while True:\n        if is_prime(number):\n            yield number\n        number += 1  If a generator function calls return or reaches the end its definition, a StopIteration exception is raised. This signals to whoever was calling next() that the generator is exhausted (this is normal iterator behavior). It is also the reason the while True: loop is present in get_primes. If it weren't, the first time next() was called we would check if the number is prime and possibly yield it. If next() were called again, we would uselessly add 1 to number and hit the end of the generator function (causing StopIteration to be raised). Once a generator has been exhausted, calling next() on it will result in an error, so you can only consume all the values of a generator once. The following will not work:   our_generator = simple_generator_function()  for value in our_generator:      print(value)  # our_generator has been exhausted...  print(next(our_generator))\nTraceback (most recent call last):\n  File  ipython-input-13-7e48a609051a , line 1, in  module \n    next(our_generator)\nStopIteration  # however, we can always create a new generator  # by calling the generator function again...  new_generator = simple_generator_function()  print(next(new_generator)) # perfectly valid\n1  Thus, the while loop is there to make sure we never reach the end of get_primes. It allows us to generate a value for as long as next() is called on the generator. This is a common idiom when dealing with infinite series (and generators in general).", 
            "title": "Magic?"
        }, 
        {
            "location": "/basic_syntax_yield/#visualizing-the-flow", 
            "text": "Let's go back to the code that was calling get_primes: solve_number_10.  def solve_number_10():\n    # She *is* working on Project Euler #10, I knew it!\n    total = 2\n    for next_prime in get_primes(3):\n        if next_prime   2000000:\n            total += next_prime\n        else:\n            print(total)\n            return  It's helpful to visualize how the first few elements are created when we call get_primes in solve_number_10's for loop. When the for loop requests the first value from get_primes, we enter get_primes as we would in a normal function.   We enter the while loop on line 3  The if condition holds (3 is prime)  We yield the value 3 and control to solve_number_10.   Then, back in solve_number_10:   The value 3 is passed back to the for loop  The for loop assigns next_prime to this value  next_prime is added to total  The for loop requests the next element from get_primes   This time, though, instead of entering get_primes back at the top, we resume at line 5, where we left off.  def get_primes(number):\n    while True:\n        if is_prime(number):\n            yield number\n        number += 1 #    Most importantly, number still has the same value it did when we called yield (i.e. 3). Remember, yield both passes a value to whoever called next(), and saves the \"state\" of the generator function. Clearly, then, number is incremented to 4, we hit the top of the while loop, and keep incrementing number until we hit the next prime number (5). Again we yield the value of number to the for loop in solve_number_10. This cycle continues until the for loop stops (at the first prime greater than 2,000,000).", 
            "title": "Visualizing the flow"
        }, 
        {
            "location": "/basic_syntax_yield/#moar-power", 
            "text": "In PEP 342, support was added for passing values into generators. PEP 342 gave generators the power to yield a value (as before), receive a value, or both yield a value and receive a (possibly different) value in a single statement.  To illustrate how values are sent to a generator, let's return to our prime number example. This time, instead of simply printing every prime number greater than number, we'll find the smallest prime number greater than successive powers of a number (i.e. for 10, we want the smallest prime greater than 10, then 100, then 1000, etc.). We start in the same way as get_primes:  def print_successive_primes(iterations, base=10):\n    # like normal functions, a generator function\n    # can be assigned to a variable\n\n    prime_generator = get_primes(base)\n    # missing code...\n    for power in range(iterations):\n        # missing code...\n\ndef get_primes(number):\n    while True:\n        if is_prime(number):\n        # ... what goes here?  The next line of get_primes takes a bit of explanation. While yield number would yield the value of number, a statement of the form other = yield foo means, \"yield foo and, when a value is sent to me, set other to that value.\" You can \"send\" values to a generator using the generator's send method.  def get_primes(number):\n    while True:\n        if is_prime(number):\n            number = yield number\n        number += 1  In this way, we can set number to a different value each time the generator yields. We can now fill in the missing code in print_successive_primes:  def print_successive_primes(iterations, base=10):\n    prime_generator = get_primes(base)\n    prime_generator.send(None)\n    for power in range(iterations):\n        print(prime_generator.send(base ** power))  Two things to note here: First, we're printing the result of generator.send, which is possible because send both sends a value to the generator and returns the value yielded by the generator (mirroring how yield works from within the generator function).  Second, notice the prime_generator.send(None) line. When you're using send to \"start\" a generator (that is, execute the code from the first line of the generator function up to the first yield statement), you must send None. This makes sense, since by definition the generator hasn't gotten to the first yield statement yet, so if we sent a real value there would be nothing to \"receive\" it. Once the generator is started, we can send values as we do above.", 
            "title": "Moar Power"
        }, 
        {
            "location": "/basic_syntax_yield/#round-up", 
            "text": "In the second half of this series, we'll discuss the various ways in which generators have been enhanced and the power they gained as a result. yield has become one of the most powerful keywords in Python. Now that we've built a solid understanding of how yield works, we have the knowledge necessary to understand some of the more \"mind-bending\" things that yield can be used for.  Believe it or not, we've barely scratched the surface of the power of yield. For example, while send does work as described above, it's almost never used when generating simple sequences like our example. Below, I've pasted a small demonstration of one common way send is used. I'll not say any more about it as figuring out how and why it works will be a good warm-up for part two.  import random\n\ndef get_data():\n     Return 3 random integers between 0 and 9 \n    return random.sample(range(10), 3)\n\ndef consume():\n     Displays a running average across lists of integers sent to it \n    running_sum = 0\n    data_items_seen = 0\n\n    while True:\n        data = yield\n        data_items_seen += len(data)\n        running_sum += sum(data)\n        print('The running average is {}'.format(running_sum / float(data_items_seen)))\n\ndef produce(consumer):\n     Produces a set of values and forwards them to the pre-defined consumer\n    function \n    while True:\n        data = get_data()\n        print('Produced {}'.format(data))\n        consumer.send(data)\n        yield\n\nif __name__ == '__main__':\n    consumer = consume()\n    consumer.send(None)\n    producer = produce(consumer)\n\n    for _ in range(10):\n        print('Producing...')\n        next(producer)", 
            "title": "Round-up"
        }, 
        {
            "location": "/basic_syntax_yield/#remember", 
            "text": "There are a few key ideas I hope you take away from this discussion:   generators are used to generate a series of values  yield is like the return of generator functions  The only other thing yield does is save the \"state\" of a generator function  A generator is just a special type of iterator  Like iterators, we can get the next value from a generator using next()  for gets values by calling next() implicitly", 
            "title": "Remember..."
        }, 
        {
            "location": "/datastructure_number/", 
            "text": "Number\n\n\nBasic Operation\n\n\n1\n1.2\n1 + 2\nabs(-5)", 
            "title": "Number"
        }, 
        {
            "location": "/datastructure_number/#number", 
            "text": "Basic Operation  1\n1.2\n1 + 2\nabs(-5)", 
            "title": "Number"
        }, 
        {
            "location": "/datastructure_collection/", 
            "text": "Collection\n\n\nIn this post I will cover 4 most popular data types in python \nlist\n, \ntuple\n, \nset\n, \ndictionary\n\n\nList\n\n\nThe most basic data structure in Python is the \nsequence\n. Each element of a sequence is assigned a number - its position or index. The first index is zero, the second index is one, and so forth.\n\n\nThe list is a most versatile datatype available in Python which can be written as a list of comma-separated values (items) between square brackets. Important thing about a list is that items in a list need not be of the same type.\n\n\nUsage\n\n\n\n\nA list keeps \norder\n, dict and set don't: when you care about order, therefore, you must use list (if your choice of containers is limited to these three, of course)\n\n\n\n\nMost Popular Operations\n\n\n\n\n\n\n\nCreate a list\n\n\n\n\n a = [\"a\", \"b\", 3] \n\n\n\n\n\n\n\n\n\nAccess values in list\n\n\n\n\n a[1] \n\n\n\n\n\n\n\n\n\nUpdated List\n\n\n\n\n a[0] = 5 \n\n\n\n\n\n\n\n\n\nDelete list elements\n\n\n\n\n del a[1] \n\n\n\n\n\n\n\nReverse a list\n\n\n\n\n a[::-1] \n\n\n\n\n\n\n\nItertools\n\n\n\n\n [a + b for (a, b) in itertools.product(x, y)] \n\n\n\n\n\n\n\nSelect random elements in list\n\n\n\n\n random.choice(x) \n\n\n random.sample(x, 3) \n\n\n\n\n\n\n\n\n\n\n\nCreate a list\n\n\na = [1, 2, 3]\n# [1, 2, 3]\n\n\n\n\nAccess values in list\n\n\nlist1 = ['physics', 'chemistry', 1997, 2000]\nlist2 = [1, 2, 3, 4, 5, 6, 7 ]\n\nprint list1[0]   # physics\n\nprint list2[1:5] # [2, 3, 4, 5]\n\n\n\n\nUpdated lists\n\n\nlist = ['physics', 'chemistry', 1997, 2000]\nprint list[2] # 1997\n\nlist[2] = 2001\nprint list[2] # 2001\n\n\n\n\nDelete list elements\n\n\nlist1 = ['physics', 'chemistry', 1997, 2000];\n\nprint list1\n# ['physics', 'chemistry', 1997, 2000]\n\ndel list1[2]\n\nprint list1\n# ['physics', 'chemistry', 2000]\n\n\n\n\nReverse a list\n\n\n[1, 3, 2][::-1]\n# [2, 3, 1]\n\n\n\n\nItertools\n\n\nimport itertools\n\nx = [1, 2, 3]\ny = [2, 4, 5]\n\n[a + b for (a, b) in itertools.product(x, y)]\n# [3, 5, 6, 4, 6, 7, 5, 7, 8]\n\n\n\n\nSelect random elements in list\n\n\nimport random\n\nx = [13, 23, 14, 52, 6, 23]\n\nrandom.choice(x) # 52\n\nrandom.sample(x, 3) # [23, 14, 52]\n\n\n\n\nTuples\n\n\nA tuple is a sequence of immutable Python objects. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.\n\n\nUsage\n\n\n\n\nTuples have structure, lists have order\n\n\nTuples being immutable there is also a semantic distinction that should guide their usage. Tuples are heterogeneous data structures (i.e., their entries have different meanings), while lists are homogeneous sequences\n\n\n\n\nMost Popular Operations\n\n\n\n\n\n\n\nCreate a tuple\n\n\n\n\n t = (\"a\", 1, 2) \n\n\n\n\n\n\n\n\n\nAccessing Values in Tuples\n\n\n\n\n t[0], t[1:] \n\n\n\n\n\n\n\n\n\nUpdating Tuples\n\n\n\n\n Not allowed \n\n\n\n\n\n\n\n\n\nCreate a tuple\n\n\ntup1 = ('physics', 'chemistry', 1997, 2000);\ntup2 = (1, 2, 3, 4, 5 );\ntup3 = \na\n, \nb\n, \nc\n, \nd\n;\ntup4 = ()\ntup5 = (50, )\n\n\n\n\nAccessing Values in Tuples\n\n\n#!/usr/bin/python\n\ntup1 = ('physics', 'chemistry', 1997, 2000);\ntup2 = (1, 2, 3, 4, 5, 6, 7 );\n\ntup1[0]\n# physics\n\ntup2[1:5]\n[2, 3, 4, 5]\n\n\n\n\nUpdating Tuples\n\n\nTuples are immutable which means you cannot update or change the values of tuple elements. You are able to take portions of existing tuples to create new tuples as the following example demonstrates\n\n\ntup1 = (12, 34.56);\ntup2 = ('abc', 'xyz');\n\n# Following action is not valid for tuples\n# tup1[0] = 100;\n\n# So let's create a new tuple as follows\ntup3 = tup1 + tup2;\nprint tup3\n\n\n\n\nSet\n\n\nSets are lists with no duplicate entries.\n\n\nThe sets module provides classes for constructing and manipulating unordered collections of unique elements. Common uses include membership testing, removing duplicates from a sequence, and computing standard math operations on sets such as intersection, union, difference, and symmetric difference.\n\n\nUsage\n\n\n\n\nset forbids duplicates, list does not: also a crucial distinction.\n\n\n\n\nMost Popular Operations\n\n\n\n\n\n\n\nCreate a set\n\n\n\n\n x = set([\"Postcard\", \"Radio\", \"Telegram\"]) \n\n\n\n\n\n\n\n\n\nAdd elements to a set\n\n\n\n\n x.add(\"Mobile\") \n\n\n\n\n\n\n\n\n\nRemove elements to a set\n\n\n\n\n x.remove(\"Radio\") \n\n\n\n\n\n\n\n\n\n\nSubset\n\n\n\n\n y.issubset(x) \n\n\n\n\n\n\n\n\n\nIntersection\n\n\n\n\n x.intersection(y) \n\n\n\n\n\n\n\n\n\nDifference between two sets\n\n\n\n\n x.difference(y) \n\n\n\n\n\n\n\n\n\nCreate a set\n\n\nx = set([\nPostcard\n, \nRadio\n, \nTelegram\n])\nx\n# set(['Postcard', 'Telegram', 'Radio'])\n\n\n\n\nAdd elements to a set\n\n\nx = set([\nPostcard\n, \nRadio\n, \nTelegram\n])\nx.add(\nMobile\n)\nx\n# set(['Postcard', 'Telegram', 'Mobile', 'Radio'])\n\n\n\n\nRemove elements to a set\n\n\nx = set([\nPostcard\n, \nRadio\n, \nTelegram\n])\nx.remove(\nRadio\n)\nx\n# set(['Postcard', 'Telegram'])\n\n\n\n\nSubset\n\n\nx = set([\na\n,\nb\n,\nc\n,\nd\n])\ny = set([\nc\n,\nd\n])\ny.issubset(x)\n# True\n\n\n\n\nIntersection\n\n\nx = set([\na\n,\nb\n,\nc\n,\nd\n])\ny = set([\nc\n,\nd\n])\nx.intersection(y)\n# set(['c', 'd'])\n\n\n\n\nDifference between two sets\n\n\nx = set([\nPostcard\n, \nRadio\n, \nTelegram\n])\ny = set([\nRadio\n,\nTelevision\n])\nx.difference(y)\n# set(['Postcard', 'Telegram'])\n\n\n\n\nDictionary\n\n\nEach \nkey\n is separated from its value by a colon (:), the items are separated by commas, and the whole thing is enclosed in curly braces. An empty dictionary without any items is written with just two curly braces, like this: {}.\n\n\nKeys are unique within a dictionary while values may not be. The values of a dictionary can be of any type, but the keys must be of an immutable data type such as strings, numbers, or tuples.\n\n\nUsage\n\n\n\n\ndict associates with each \nkey a value\n, while list and set just contain values: very different use cases, obviously.\n\n\n\n\nMost Popular Operations\n\n\n\n\n\n\n\nCreate a dictionary\n\n\n\n\n d = {\"a\": 1, \"b\": 2, \"c\": 3} \n\n\n\n\n\n\n\nUpdate dictionary\n\n\n\n\n d[\"a\"] = 4 \n\n\n\n\n\n\n\nDelete dictionary elements\n\n\n\n\n del d[\"a\"] \n\n\n\n\n\n\n\n\n\nCreate a dictionary\n\n\ndict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}\n\nprint \ndict['Name']: \n, dict['Name']\nprint \ndict['Age']: \n, dict['Age']\n\n\n\n\nUpdate dictionary\n\n\ndict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}\n\ndict['Age'] = 8; # update existing entry\ndict['School'] = \nDPS School\n; # Add new entry\n\n\nprint \ndict['Age']: \n, dict['Age']\nprint \ndict['School']: \n, dict['School']\n\n\n\n\nDelete dictionary elements\n\n\ndict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}\n\ndel dict['Name']; # remove entry with key 'Name'\ndict.clear();     # remove all entries in dict\ndel dict ;        # delete entire dictionary\n\nprint \ndict['Age']: \n, dict['Age']\nprint \ndict['School']: \n, dict['School']\n\n\n\n\nRelated Readings\n\n\n\n\nPython Lists, \ntutorialspoint.com\n\n\nPython Dictionary, \ntutorialspoint.com\n\n\nPython Dictionary Methods, \nguru99\n\n\nIn Python, when to use a Dictionary, List or Set?, \nstackoverflow\n\n\nWhat's the difference between lists and tuples?, \nstackoverflow", 
            "title": "Collection (List, Set, Turple)"
        }, 
        {
            "location": "/datastructure_collection/#collection", 
            "text": "In this post I will cover 4 most popular data types in python  list ,  tuple ,  set ,  dictionary", 
            "title": "Collection"
        }, 
        {
            "location": "/datastructure_collection/#list", 
            "text": "The most basic data structure in Python is the  sequence . Each element of a sequence is assigned a number - its position or index. The first index is zero, the second index is one, and so forth.  The list is a most versatile datatype available in Python which can be written as a list of comma-separated values (items) between square brackets. Important thing about a list is that items in a list need not be of the same type.  Usage   A list keeps  order , dict and set don't: when you care about order, therefore, you must use list (if your choice of containers is limited to these three, of course)   Most Popular Operations    Create a list    a = [\"a\", \"b\", 3]      Access values in list    a[1]      Updated List    a[0] = 5      Delete list elements    del a[1]     Reverse a list    a[::-1]     Itertools    [a + b for (a, b) in itertools.product(x, y)]     Select random elements in list    random.choice(x)    random.sample(x, 3)", 
            "title": "List"
        }, 
        {
            "location": "/datastructure_collection/#create-a-list", 
            "text": "a = [1, 2, 3]\n# [1, 2, 3]", 
            "title": "Create a list"
        }, 
        {
            "location": "/datastructure_collection/#access-values-in-list", 
            "text": "list1 = ['physics', 'chemistry', 1997, 2000]\nlist2 = [1, 2, 3, 4, 5, 6, 7 ]\n\nprint list1[0]   # physics\n\nprint list2[1:5] # [2, 3, 4, 5]", 
            "title": "Access values in list"
        }, 
        {
            "location": "/datastructure_collection/#updated-lists", 
            "text": "list = ['physics', 'chemistry', 1997, 2000]\nprint list[2] # 1997\n\nlist[2] = 2001\nprint list[2] # 2001", 
            "title": "Updated lists"
        }, 
        {
            "location": "/datastructure_collection/#delete-list-elements", 
            "text": "list1 = ['physics', 'chemistry', 1997, 2000];\n\nprint list1\n# ['physics', 'chemistry', 1997, 2000]\n\ndel list1[2]\n\nprint list1\n# ['physics', 'chemistry', 2000]", 
            "title": "Delete list elements"
        }, 
        {
            "location": "/datastructure_collection/#reverse-a-list", 
            "text": "[1, 3, 2][::-1]\n# [2, 3, 1]", 
            "title": "Reverse a list"
        }, 
        {
            "location": "/datastructure_collection/#itertools", 
            "text": "import itertools\n\nx = [1, 2, 3]\ny = [2, 4, 5]\n\n[a + b for (a, b) in itertools.product(x, y)]\n# [3, 5, 6, 4, 6, 7, 5, 7, 8]", 
            "title": "Itertools"
        }, 
        {
            "location": "/datastructure_collection/#select-random-elements-in-list", 
            "text": "import random\n\nx = [13, 23, 14, 52, 6, 23]\n\nrandom.choice(x) # 52\n\nrandom.sample(x, 3) # [23, 14, 52]", 
            "title": "Select random elements in list"
        }, 
        {
            "location": "/datastructure_collection/#tuples", 
            "text": "A tuple is a sequence of immutable Python objects. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.  Usage   Tuples have structure, lists have order  Tuples being immutable there is also a semantic distinction that should guide their usage. Tuples are heterogeneous data structures (i.e., their entries have different meanings), while lists are homogeneous sequences   Most Popular Operations    Create a tuple    t = (\"a\", 1, 2)      Accessing Values in Tuples    t[0], t[1:]      Updating Tuples    Not allowed", 
            "title": "Tuples"
        }, 
        {
            "location": "/datastructure_collection/#create-a-tuple", 
            "text": "tup1 = ('physics', 'chemistry', 1997, 2000);\ntup2 = (1, 2, 3, 4, 5 );\ntup3 =  a ,  b ,  c ,  d ;\ntup4 = ()\ntup5 = (50, )", 
            "title": "Create a tuple"
        }, 
        {
            "location": "/datastructure_collection/#accessing-values-in-tuples", 
            "text": "#!/usr/bin/python\n\ntup1 = ('physics', 'chemistry', 1997, 2000);\ntup2 = (1, 2, 3, 4, 5, 6, 7 );\n\ntup1[0]\n# physics\n\ntup2[1:5]\n[2, 3, 4, 5]", 
            "title": "Accessing Values in Tuples"
        }, 
        {
            "location": "/datastructure_collection/#updating-tuples", 
            "text": "Tuples are immutable which means you cannot update or change the values of tuple elements. You are able to take portions of existing tuples to create new tuples as the following example demonstrates  tup1 = (12, 34.56);\ntup2 = ('abc', 'xyz');\n\n# Following action is not valid for tuples\n# tup1[0] = 100;\n\n# So let's create a new tuple as follows\ntup3 = tup1 + tup2;\nprint tup3", 
            "title": "Updating Tuples"
        }, 
        {
            "location": "/datastructure_collection/#set", 
            "text": "Sets are lists with no duplicate entries.  The sets module provides classes for constructing and manipulating unordered collections of unique elements. Common uses include membership testing, removing duplicates from a sequence, and computing standard math operations on sets such as intersection, union, difference, and symmetric difference.  Usage   set forbids duplicates, list does not: also a crucial distinction.   Most Popular Operations    Create a set    x = set([\"Postcard\", \"Radio\", \"Telegram\"])      Add elements to a set    x.add(\"Mobile\")      Remove elements to a set    x.remove(\"Radio\")      Subset    y.issubset(x)      Intersection    x.intersection(y)      Difference between two sets    x.difference(y)", 
            "title": "Set"
        }, 
        {
            "location": "/datastructure_collection/#create-a-set", 
            "text": "x = set([ Postcard ,  Radio ,  Telegram ])\nx\n# set(['Postcard', 'Telegram', 'Radio'])", 
            "title": "Create a set"
        }, 
        {
            "location": "/datastructure_collection/#add-elements-to-a-set", 
            "text": "x = set([ Postcard ,  Radio ,  Telegram ])\nx.add( Mobile )\nx\n# set(['Postcard', 'Telegram', 'Mobile', 'Radio'])", 
            "title": "Add elements to a set"
        }, 
        {
            "location": "/datastructure_collection/#remove-elements-to-a-set", 
            "text": "x = set([ Postcard ,  Radio ,  Telegram ])\nx.remove( Radio )\nx\n# set(['Postcard', 'Telegram'])", 
            "title": "Remove elements to a set"
        }, 
        {
            "location": "/datastructure_collection/#subset", 
            "text": "x = set([ a , b , c , d ])\ny = set([ c , d ])\ny.issubset(x)\n# True", 
            "title": "Subset"
        }, 
        {
            "location": "/datastructure_collection/#intersection", 
            "text": "x = set([ a , b , c , d ])\ny = set([ c , d ])\nx.intersection(y)\n# set(['c', 'd'])", 
            "title": "Intersection"
        }, 
        {
            "location": "/datastructure_collection/#difference-between-two-sets", 
            "text": "x = set([ Postcard ,  Radio ,  Telegram ])\ny = set([ Radio , Television ])\nx.difference(y)\n# set(['Postcard', 'Telegram'])", 
            "title": "Difference between two sets"
        }, 
        {
            "location": "/datastructure_collection/#dictionary", 
            "text": "Each  key  is separated from its value by a colon (:), the items are separated by commas, and the whole thing is enclosed in curly braces. An empty dictionary without any items is written with just two curly braces, like this: {}.  Keys are unique within a dictionary while values may not be. The values of a dictionary can be of any type, but the keys must be of an immutable data type such as strings, numbers, or tuples.  Usage   dict associates with each  key a value , while list and set just contain values: very different use cases, obviously.   Most Popular Operations    Create a dictionary    d = {\"a\": 1, \"b\": 2, \"c\": 3}     Update dictionary    d[\"a\"] = 4     Delete dictionary elements    del d[\"a\"]", 
            "title": "Dictionary"
        }, 
        {
            "location": "/datastructure_collection/#create-a-dictionary", 
            "text": "dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}\n\nprint  dict['Name']:  , dict['Name']\nprint  dict['Age']:  , dict['Age']", 
            "title": "Create a dictionary"
        }, 
        {
            "location": "/datastructure_collection/#update-dictionary", 
            "text": "dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}\n\ndict['Age'] = 8; # update existing entry\ndict['School'] =  DPS School ; # Add new entry\n\n\nprint  dict['Age']:  , dict['Age']\nprint  dict['School']:  , dict['School']", 
            "title": "Update dictionary"
        }, 
        {
            "location": "/datastructure_collection/#delete-dictionary-elements", 
            "text": "dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}\n\ndel dict['Name']; # remove entry with key 'Name'\ndict.clear();     # remove all entries in dict\ndel dict ;        # delete entire dictionary\n\nprint  dict['Age']:  , dict['Age']\nprint  dict['School']:  , dict['School']", 
            "title": "Delete dictionary elements"
        }, 
        {
            "location": "/datastructure_collection/#related-readings", 
            "text": "Python Lists,  tutorialspoint.com  Python Dictionary,  tutorialspoint.com  Python Dictionary Methods,  guru99  In Python, when to use a Dictionary, List or Set?,  stackoverflow  What's the difference between lists and tuples?,  stackoverflow", 
            "title": "Related Readings"
        }, 
        {
            "location": "/datastructure_string/", 
            "text": "Format\n\n\n'{0}, {1}, {2}'.format('a', 'b', 'c')\n# 'a, b, c'\n\n\n\n\nRegular Expressions\n\n\nThe aim of this chapter of our Python tutorial is to present a detailed led and descriptive introduction into regular expressions. This introduction will explain the theoretical aspects of regular expressions and will show you how to use them in Python scripts. \n\n\nRegular Expressions are used in programming languages to filter texts or textstrings. It's possible to check, if a text or a string matches a regular expression. \n\n\nThere is an aspect of regular expressions which shouldn't go unmentioned: The syntax of regular expressions is the same for all programming and script languages, e.g. Python, Perl, Java, SED, AWK and even X#.\n\n\nFunctions\n\n\nmatch function\n\n\nThis function attempts to match RE pattern to string with optional flags.\n\n\nre.match(pattern, string, flags=0)\n\n\n\n\nExample\n\n\nimport re\n\nline = \nCats are smarter than dogs\n\n\nmatched_object = re.match(r'(.*) are (.*?) .*', line, re.M | re.I)\n\nif matched_object:\n    print \nmatched_object.group()  : \n, matched_object.group()\n    print \nmatched_object.group(1) : \n, matched_object.group(1)\n    print \nmatched_object.group(2) : \n, matched_object.group(2)\nelse:\n    print \nNo match!!\n\n\n\n\n\nWhen the code is executed, it produces following results\n\n\nmatched_object.group()  :  Cats are smarter than dogs\nmatched_object.group(1) :  Cats\nmatched_object.group(2) :  smarter\n\n\n\n\nsearch function\n\n\nThis function searches for first occurrence of RE pattern within stirng with optional flags\n\n\nre.search(pattern, string, flags=0)\n\n\n\n\nExample\n\n\n#!/usr/bin/python\nimport re\n\nline = \nCats are smarter than dogs\n\n\nsearch_object = re.search(r'dogs', line, re.M | re.I)\nif search_object:\n    print \nsearch --\n search_object.group() : \n, search_object.group()\nelse:\n    print \nNothing found!!\n\n\n\n\n\nWhen the code is executed, it produces following results\n\n\nsearch --\n search_object.group() :  dogs\n\n\n\n\nsub function\n\n\nThis method replaces all occurrences of the RE pattern in string with repl, substituting all occurrences unless max provided. This method returns modified string.\n\n\nre.sub(pattern, repl, string, max=0)\n\n\n\n\nExample\n\n\n#!/usr/bin/python\nimport re\n\nphone = \n2004-959-559 # This is Phone Number\n\n\n# Delete Python-style comments\nnum = re.sub(r'#.*$', \n, phone)\nprint \nPhone Num : \n, num\n\n# Remove anything other than digits\nnum = re.sub(r'\\D', \n, phone)    \nprint \nPhone Num : \n, num\n\n\n\n\nWhen the code is executed, it produces following results\n\n\nPhone Num :  2004-959-559\nPhone Num :  2004959559\n\n\n\n\nTokens Cheatsheet\n\n\n\n\n\n\nCharacter Classes\n\n\n\n\n.\n \nany character except newline\n\n\n\n\n /go\n.\ngle/ \n\n\n \ngoogle\n \ngoggle\n gogle \n\n\n\n\n\n\n\n\n\n\\w \\d \\s\n \nword, digit, whitespace\n\n\n\n\n /\n\\w\n/ \n\n\n \nAaYyz09\n ?! \n\n\n /\n\\d\n/ \n\n\n \n0\n1\n2\n3\n4\n5\n aZ? \n\n\n /\n\\s\n/ \n\n\n 0123456789\n \nabcd?/ \n\n\n\n\n\n\n\n\n\n\n\\W \\D \\S\n \nnot word, digit, whitespace\n\n\n\n\n /\n\\W\n/ \n\n\n abcded\n1234\n \n?\n>\n\n\n /\n\\D\n/ \n\n\n \na\nb\nc\n 12345 \n?\n<\n.\n\n\n /\n\\S\n/ \n\n\n \na\nb\nc\n1\n2\n3\n?\n<\n.\n\n\n\n\n\n\n\n\n\n[abc]\n \nany of a, b or c\n\n\n\n\n /analy\n[\nsz\n]\ne/ \n\n\nanalyse\n \nanalyze\n analyxe \n\n\n\n\n\n\n\n\n\n[^abc]\n \nnot a, b or c\n\n\n\n\n /analy\n[\n^sz\n]\ne/ \n\n\nanalyse analyze \nanalyxe\n \n\n\n\n\n\n\n\n\n\n[a-g]\n \ncharacter between a \n&\n g\n\n\n\n\n /\n[\n2\n-\n4\n]\n/ \n\n\n demo1 \ndemo2\n \ndemo3\n \ndemo4\n demo5\n\n\n\n\n\n\n\nQuantifiers \n&\n Alternation\n\n\na* a+ a?\n \n0 or more, 1 or more, 0 or 1\n\n\n\n\n /go\n*\ngle/ \n\n\n \ngogle\n \ngogle\n \ngoogle\n \ngooooogle\n hgle\n\n\n /go\n+\ngle/ \n\n\n ggle \ngogle\n \ngoogle\n \ngooooogle\n hgle\n\n\n /go\n?\ngle/ \n\n\n \nggle\n \ngogle\n google gooooogle hgle\n\n\n\n\n\n\n\na{5}, a{2,}\n \nexactly five, two or more\n\n\n\n\n /go\n{5}\ngle/ \n\n\n gogle gogle google \ngooooogle\n hgle\n\n\n /go\n{2,}\ngle/ \n\n\n gogle gogle \ngoogle\n \ngooooogle\n hgle\n\n\n\n\n\n\na{1,3}\n \nbetween one \n&\n three\n\n\n\n\n /go\n{1,3}\ngle/ \n\n\n gogle \ngogle\n \ngoogle\n \ngooogle\n gooooogle hgle\n\n\n\n\n\n\na+? a{2,}?\n \nmatch as few as possible\n\n\n\n\n /a\n+?\n/ \n\n\n \na\n \naa\n \naaaaaa\n\n\n /a\n{2,}?\n/ \n\n\n a \naa\n \naaaaaa\n\n\n\n\n\n\nab|cd\n \nmatch ab or cd\n\n\n\n\n /demo\n|\nexample/ \n\n\n \ndemo\n \nexample\n \nexample\n1\n\n\n\n\n\n\n\nAnchors\n\n\n^abc$\n \nstart / end of the string\n\n\n\n\n /\n^abc$\n/ \n\n\n \nabc\n\n\n /\n^abc\n/ \n\n\n \nabc\n abc\n\n\n /\nabc$\n/ \n\n\n abc \nabc\n\n\n\n\n\n\n\\b \\B\n \n word, not-word boundary\n\n\n\n\n /\n\\b\nis\n\\b\n/ \n\n\nThis island \nis\n beautiful.\n\n\n /\n\\B\ncat\n\\B\n/ \n\n\n cat certifi\ncat\ne\n\n\n\n\n\n\n\nEscaped characters\n\n\n\\. \\* \\\\\n \nescaped special characters\n\n\n\n\n /\n\\.\n/ \n\n\n username@exampe\n.\ncom 300\n.\n000 USD\n\n\n /\n\\*\n/ \n\n\n abc@\n&\n%$\n*\n123\n\n\n /\n\\\\\n/ \n\n\n abc@\n&\n%$\n\\\\\n123\n\n\n\n\n\n\n\n\\t \\n \\r\n \ntab, linefeed, carriage return\n\n\n\n\n /\n\\t\n/ \n\n\n abc\ndef\n\n\n /ab\n\\n\n/ \n\n\n \nab\n\n\n /\n\\r\n/ \n\n\n abc@\n&\n%$\n\\\\\n123\n\n\n\n\n\n\n\n\n\n\\u00A9\n \nunicode escaped \u00a9\n\n\n /\n\\u00A9\n/ \n\n\n Copyright\n\u00a9\n2017 - All rights reserved\n\n\n\n\n\n\n\nGroups and Lockaround\n\n\n(abc)\n \ncapture group\n\n\n\n\n /\n(\ndemo\n|\nexample\n)\n[0-9]\n/ \n\n\n \ndemo1\nexample4\ndemo \n\n\n\n\n\n\n\n\\1\n \nbackreference to group #1\n\n\n\n\n /\n(\nabc\n|\ndef\n)\n=\n\\1\n/\n\n\n \nabc=abc\n \ndef=def\nabc=def \n\n\n\n\n\n\n\n(?:abc)\n \nnon-capturing group\n\n\n\n\n /\n(\n?:\nabc\n)\n{3}\n/\n\n\n \nabcabcabc\n abcabc\n \n\n\n\n\n\n\n\n(?=abc)\n \npositive lookahead\n\n\n\n\n /t\n(?=\ns\n)\n/\n\n\n tt\nt\nssstt\nt\nss \n\n\n\n\n\n\n\n(?!abc)\n \nnegative lookahead\n\n\n\n\n /t\n(?!\ns\n)\n/\n\n\n \nt\nt\ntsss\nt\nt\ntss \n\n\n\n\n\n\n\n\n\n(?\n<\n=abc)\n \npositive lookbehind\n\n\n\n\n /\n(?\n<\n=\nfoo\n)\nbar/\n\n\n foo\nbar\n fuubar \n\n\n\n\n\n\n\n\n\n(?\n!abc)\n \nnegative lookbehind\n\n\n\n\n /\n(?\n!\nfoo\n)\nbar/ \n\n\n foobar fuu\nbar\n \n\n\n\n\n\n\n\n\n\n\nRelated Readings\n\n\n\n\nOnline regex tester and debugger: PHP, PCRE, Python, Golang and JavaScript, \nregex101.com\n\n\nRegExr: Learn, Build, \n Test RegEx, \nregexr.com", 
            "title": "String"
        }, 
        {
            "location": "/datastructure_string/#format", 
            "text": "'{0}, {1}, {2}'.format('a', 'b', 'c')\n# 'a, b, c'", 
            "title": "Format"
        }, 
        {
            "location": "/datastructure_string/#regular-expressions", 
            "text": "The aim of this chapter of our Python tutorial is to present a detailed led and descriptive introduction into regular expressions. This introduction will explain the theoretical aspects of regular expressions and will show you how to use them in Python scripts.   Regular Expressions are used in programming languages to filter texts or textstrings. It's possible to check, if a text or a string matches a regular expression.   There is an aspect of regular expressions which shouldn't go unmentioned: The syntax of regular expressions is the same for all programming and script languages, e.g. Python, Perl, Java, SED, AWK and even X#.", 
            "title": "Regular Expressions"
        }, 
        {
            "location": "/datastructure_string/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/datastructure_string/#match-function", 
            "text": "This function attempts to match RE pattern to string with optional flags.  re.match(pattern, string, flags=0)  Example  import re\n\nline =  Cats are smarter than dogs \n\nmatched_object = re.match(r'(.*) are (.*?) .*', line, re.M | re.I)\n\nif matched_object:\n    print  matched_object.group()  :  , matched_object.group()\n    print  matched_object.group(1) :  , matched_object.group(1)\n    print  matched_object.group(2) :  , matched_object.group(2)\nelse:\n    print  No match!!   When the code is executed, it produces following results  matched_object.group()  :  Cats are smarter than dogs\nmatched_object.group(1) :  Cats\nmatched_object.group(2) :  smarter", 
            "title": "match function"
        }, 
        {
            "location": "/datastructure_string/#search-function", 
            "text": "This function searches for first occurrence of RE pattern within stirng with optional flags  re.search(pattern, string, flags=0)  Example  #!/usr/bin/python\nimport re\n\nline =  Cats are smarter than dogs \n\nsearch_object = re.search(r'dogs', line, re.M | re.I)\nif search_object:\n    print  search --  search_object.group() :  , search_object.group()\nelse:\n    print  Nothing found!!   When the code is executed, it produces following results  search --  search_object.group() :  dogs", 
            "title": "search function"
        }, 
        {
            "location": "/datastructure_string/#sub-function", 
            "text": "This method replaces all occurrences of the RE pattern in string with repl, substituting all occurrences unless max provided. This method returns modified string.  re.sub(pattern, repl, string, max=0)  Example  #!/usr/bin/python\nimport re\n\nphone =  2004-959-559 # This is Phone Number \n\n# Delete Python-style comments\nnum = re.sub(r'#.*$',  , phone)\nprint  Phone Num :  , num\n\n# Remove anything other than digits\nnum = re.sub(r'\\D',  , phone)    \nprint  Phone Num :  , num  When the code is executed, it produces following results  Phone Num :  2004-959-559\nPhone Num :  2004959559", 
            "title": "sub function"
        }, 
        {
            "location": "/datastructure_string/#tokens-cheatsheet", 
            "text": "Character Classes   .   any character except newline    /go . gle/     google   goggle  gogle      \\w \\d \\s   word, digit, whitespace    / \\w /     AaYyz09  ?!    / \\d /     0 1 2 3 4 5  aZ?    / \\s /    0123456789   abcd?/      \\W \\D \\S   not word, digit, whitespace    / \\W /    abcded 1234   ? >   / \\D /     a b c  12345  ? < .   / \\S /     a b c 1 2 3 ? < .     [abc]   any of a, b or c    /analy [ sz ] e/   analyse   analyze  analyxe      [^abc]   not a, b or c    /analy [ ^sz ] e/   analyse analyze  analyxe       [a-g]   character between a  &  g    / [ 2 - 4 ] /    demo1  demo2   demo3   demo4  demo5    Quantifiers  &  Alternation  a* a+ a?   0 or more, 1 or more, 0 or 1    /go * gle/     gogle   gogle   google   gooooogle  hgle   /go + gle/    ggle  gogle   google   gooooogle  hgle   /go ? gle/     ggle   gogle  google gooooogle hgle    a{5}, a{2,}   exactly five, two or more    /go {5} gle/    gogle gogle google  gooooogle  hgle   /go {2,} gle/    gogle gogle  google   gooooogle  hgle    a{1,3}   between one  &  three    /go {1,3} gle/    gogle  gogle   google   gooogle  gooooogle hgle    a+? a{2,}?   match as few as possible    /a +? /     a   aa   aaaaaa   /a {2,}? /    a  aa   aaaaaa    ab|cd   match ab or cd    /demo | example/     demo   example   example 1    Anchors  ^abc$   start / end of the string    / ^abc$ /     abc   / ^abc /     abc  abc   / abc$ /    abc  abc    \\b \\B    word, not-word boundary    / \\b is \\b /   This island  is  beautiful.   / \\B cat \\B /    cat certifi cat e    Escaped characters  \\. \\* \\\\   escaped special characters    / \\. /    username@exampe . com 300 . 000 USD   / \\* /    abc@ & %$ * 123   / \\\\ /    abc@ & %$ \\\\ 123    \\t \\n \\r   tab, linefeed, carriage return    / \\t /    abc def   /ab \\n /     ab   / \\r /    abc@ & %$ \\\\ 123     \\u00A9   unicode escaped \u00a9   / \\u00A9 /    Copyright \u00a9 2017 - All rights reserved    Groups and Lockaround  (abc)   capture group    / ( demo | example ) [0-9] /     demo1 example4 demo     \\1   backreference to group #1    / ( abc | def ) = \\1 /    abc=abc   def=def abc=def     (?:abc)   non-capturing group    / ( ?: abc ) {3} /    abcabcabc  abcabc      (?=abc)   positive lookahead    /t (?= s ) /   tt t ssstt t ss     (?!abc)   negative lookahead    /t (?! s ) /    t t tsss t t tss      (? < =abc)   positive lookbehind    / (? < = foo ) bar/   foo bar  fuubar      (? !abc)   negative lookbehind    / (? ! foo ) bar/    foobar fuu bar       Related Readings   Online regex tester and debugger: PHP, PCRE, Python, Golang and JavaScript,  regex101.com  RegExr: Learn, Build,   Test RegEx,  regexr.com", 
            "title": "Tokens Cheatsheet"
        }, 
        {
            "location": "/datastructure_time/", 
            "text": "Datetime\n\n\nPrint current time\n\n\nfrom datetime import datetime\ndatetime.now().strftime('%Y-%m-%d %H:%M:%S')\n# '2015-12-29 14:02:27'\n\n\n\n\nGet current time\n\n\nimport datetime\ndatetime.datetime.now()\n# datetime(2009, 1, 6, 15, 8, 24, 78915)\n\n\n\n\nUnixtime\n\n\nimport time\nint(time.time())\n\n\n\n\nMeasure time elapsed\n\n\nimport time\n\nstart = time.time()\nprint(\nhello\n)\nend = time.time()\nprint(end - start)\n\n\n\n\nMoment\n\n\nDealing with dates in Python shouldn't have to suck.\n\n\nInstallation\n\n\npip install moment\n\n\n\n\nUsage\n\n\nimport moment\nfrom datetime import datetime\n\n# Create a moment from a string\nmoment.date(\n12-18-2012\n)\n\n# Create a moment with a specified strftime format\nmoment.date(\n12-18-2012\n, \n%m-%d-%Y\n)\n\n# Moment uses the awesome dateparser library behind the scenes\nmoment.date(\n2012-12-18\n)\n\n# Create a moment with words in it\nmoment.date(\nDecember 18, 2012\n)\n\n# Create a moment that would normally be pretty hard to do\nmoment.date(\n2 weeks ago\n)\n\n# Create a future moment that would otherwise be really difficult\nmoment.date(\n2 weeks from now\n)\n\n# Create a moment from the current datetime\nmoment.now()\n\n# The moment can also be UTC-based\nmoment.utcnow()\n\n# Create a moment with the UTC time zone\nmoment.utc(\n2012-12-18\n)\n\n# Create a moment from a Unix timestamp\nmoment.unix(1355875153626)\n\n# Create a moment from a Unix UTC timestamp\nmoment.unix(1355875153626, utc=True)\n\n# Return a datetime instance\nmoment.date(2012, 12, 18).date\n\n# We can do the same thing with the UTC method\nmoment.utc(2012, 12, 18).date\n\n# Create and format a moment using Moment.js semantics\nmoment.now().format(\nYYYY-M-D\n)\n\n# Create and format a moment with strftime semantics\nmoment.date(2012, 12, 18).strftime(\n%Y-%m-%d\n)\n\n# Update your moment's time zone\nmoment.date(datetime(2012, 12, 18)).locale(\nUS/Central\n).date\n\n# Alter the moment's UTC time zone to a different time zone\nmoment.utcnow().timezone(\nUS/Eastern\n).date\n\n# Set and update your moment's time zone. For instance, I'm on the\n# west coast, but want NYC's current time.\nmoment.now().locale(\nUS/Pacific\n).timezone(\nUS/Eastern\n)\n\n# In order to manipulate time zones, a locale must always be set or\n# you must be using UTC.\nmoment.utcnow().timezone(\nUS/Eastern\n).date\n\n# You can also clone a moment, so the original stays unaltered\nnow = moment.utcnow().timezone(\nUS/Pacific\n)\nfuture = now.clone().add(weeks=2)\n\n\n\n\nRelated Readings\n\n\n\n\nHow to get current time in Python, \nstackoverflow\n\n\nDoes Python's time.time() return the local or UTC timestamp?, \nstackoverflow\n\n\nMeasure time elapsed in Python?, \nstackoverflow\n\n\nmomnet, \nhttps://github.com/zachwill/moment", 
            "title": "Datetime"
        }, 
        {
            "location": "/datastructure_time/#datetime", 
            "text": "Print current time  from datetime import datetime\ndatetime.now().strftime('%Y-%m-%d %H:%M:%S')\n# '2015-12-29 14:02:27'  Get current time  import datetime\ndatetime.datetime.now()\n# datetime(2009, 1, 6, 15, 8, 24, 78915)  Unixtime  import time\nint(time.time())  Measure time elapsed  import time\n\nstart = time.time()\nprint( hello )\nend = time.time()\nprint(end - start)", 
            "title": "Datetime"
        }, 
        {
            "location": "/datastructure_time/#moment", 
            "text": "Dealing with dates in Python shouldn't have to suck.  Installation  pip install moment  Usage  import moment\nfrom datetime import datetime\n\n# Create a moment from a string\nmoment.date( 12-18-2012 )\n\n# Create a moment with a specified strftime format\nmoment.date( 12-18-2012 ,  %m-%d-%Y )\n\n# Moment uses the awesome dateparser library behind the scenes\nmoment.date( 2012-12-18 )\n\n# Create a moment with words in it\nmoment.date( December 18, 2012 )\n\n# Create a moment that would normally be pretty hard to do\nmoment.date( 2 weeks ago )\n\n# Create a future moment that would otherwise be really difficult\nmoment.date( 2 weeks from now )\n\n# Create a moment from the current datetime\nmoment.now()\n\n# The moment can also be UTC-based\nmoment.utcnow()\n\n# Create a moment with the UTC time zone\nmoment.utc( 2012-12-18 )\n\n# Create a moment from a Unix timestamp\nmoment.unix(1355875153626)\n\n# Create a moment from a Unix UTC timestamp\nmoment.unix(1355875153626, utc=True)\n\n# Return a datetime instance\nmoment.date(2012, 12, 18).date\n\n# We can do the same thing with the UTC method\nmoment.utc(2012, 12, 18).date\n\n# Create and format a moment using Moment.js semantics\nmoment.now().format( YYYY-M-D )\n\n# Create and format a moment with strftime semantics\nmoment.date(2012, 12, 18).strftime( %Y-%m-%d )\n\n# Update your moment's time zone\nmoment.date(datetime(2012, 12, 18)).locale( US/Central ).date\n\n# Alter the moment's UTC time zone to a different time zone\nmoment.utcnow().timezone( US/Eastern ).date\n\n# Set and update your moment's time zone. For instance, I'm on the\n# west coast, but want NYC's current time.\nmoment.now().locale( US/Pacific ).timezone( US/Eastern )\n\n# In order to manipulate time zones, a locale must always be set or\n# you must be using UTC.\nmoment.utcnow().timezone( US/Eastern ).date\n\n# You can also clone a moment, so the original stays unaltered\nnow = moment.utcnow().timezone( US/Pacific )\nfuture = now.clone().add(weeks=2)", 
            "title": "Moment"
        }, 
        {
            "location": "/datastructure_time/#related-readings", 
            "text": "How to get current time in Python,  stackoverflow  Does Python's time.time() return the local or UTC timestamp?,  stackoverflow  Measure time elapsed in Python?,  stackoverflow  momnet,  https://github.com/zachwill/moment", 
            "title": "Related Readings"
        }, 
        {
            "location": "/datastructure_object/", 
            "text": "Convert dict to object\n\n\nElegant way to convert a normal Python dict with some nested dicts to an object\n\n\nclass Struct:\n    def __init__(self, **entries):\n        self.__dict__.update(entries)\n\n\n\n\nThen, you can use\n\n\n args = {'a': 1, 'b': 2}\n\n s = Struct(**args)\n\n s\n\n __main__.Struct instance at 0x01D6A738 \n\n\n s.a\n1\n\n s.b\n2\n\n\n\n\nRelated Readings\n\n\n\n\nstackoverflow, Convert Python dict to object?", 
            "title": "Object"
        }, 
        {
            "location": "/datastructure_object/#convert-dict-to-object", 
            "text": "Elegant way to convert a normal Python dict with some nested dicts to an object  class Struct:\n    def __init__(self, **entries):\n        self.__dict__.update(entries)  Then, you can use   args = {'a': 1, 'b': 2}  s = Struct(**args)  s  __main__.Struct instance at 0x01D6A738    s.a\n1  s.b\n2  Related Readings   stackoverflow, Convert Python dict to object?", 
            "title": "Convert dict to object"
        }, 
        {
            "location": "/oop/", 
            "text": "Object Oriented Programming\n\n\nPython has been an object-oriented language since it existed. Because of this, creating and using classes and objects are downright easy. This chapter helps you become an expert in using Python's object-oriented programming support.\n\n\nIf you do not have any previous experience with object-oriented (OO) programming, you may want to consult an introductory course on it or at least a tutorial of some sort so that you have a grasp of the basic concepts.\n\n\nClasses and Objects\n\n\nClasses can be thought of as blueprints for creating objects. When I define a \nBankAccount\n class using the class keyword, I haven't actually created a bank account. Instead, what I've created is a sort of instruction manual for constructing \"bank account\" objects. Let's look at the following example code:\n\n\nclass BankAccount:\n    id = None\n    balance = 0\n\n    def __init__(self, id, balance=0):\n        self.id = id\n        self.balance = balance\n\n    def __get_balance(self):\n        return self.balance\n\n    def withdraw(self, amount):\n        self.balance = self.balance - amount\n\n    def deposit(self, amount):\n        self.balance = self.balance + amount\n\njohn = BankAccount(1, 1000.0)\njohn.withdraw(100.0)\n\n\n\n\nThe \nclass BankAccount\n line \ndoes not\n create a new bank account. That is, just because we've \ndefined\n a \nBankAcount\n doesn't mean we've \ncreated\n on; we've merely outlined the \nblueprint\n to create a \nBankAccount\n object. To do so, we call the class's \n__init__\n method with the proper number of arguments (minus \nself\n, which we'll get to in a moment)\n\n\nSo, to use the \"blueprint\" that we crated by defining the \nclass BankAccount\n (which is used to create \nBankAccount\n objects), we call the class name almost as if it were a function: \njohn = BankAccount(1, 1000.0)\n. This line simple say \"use the \nBankAccount\n blueprint to create me a new object, which I'll refer to as \njohn\n\".\n\n\nThe \njohn\n \nobject\n, known as an \ninstance\n, is the realized version of the \nBankAccount\n \nclass\n. Before we called \nBankAccount()\n, no \nBankAccount\n object existed. We can, of course, create as many \nBankAccount\n objects as we'd like. There is still, however, only one \nBankAccount\n \nclass\n, regardless of how many \ninstances\n of the class we create.\n\n\nself\n\n\nSo what's with that \nself\n parameter to all of the \nBankAccount\n methods? What is it? Why, it's the instance, of course! Put another way, a method like withdraw defines the instructions for withdrawing money from some abstract customer's account. Calling \njohn.withdraw(100)\n puts those instructions to use on the \njohn\n instance.\n\n\nSo when we say def \nwithdraw(self, amount)\n:, we're saying, \"here's how you withdraw money from a \nBankAccount\n object (which we'll call \nself\n) and a dollar figure (which we'll call \namount\n). \nself\n is the \ninstance\n of the \nBankAccount\n that \nwithdraw\n is being called on. That's not me making analogies, either. \njohn.withdraw(100.0)\n is just shorthand for \nBankAccount.withdraw(john, 100.0)\n, which is perfectly valid (if not often seen) code.\n\n\nConstructors: \n__init__\n\n\nself\n may make sense for other methods, but what about \n__init__\n? When we call \n__init__\n, we're in the process of creating an object, so how can there already be a \nself\n? Python allows us to extend the \nself\n pattern to when objects are constructed as well, even though it doesn't \nexactly\n fit. Just imagine that \njohn = (1, 1000.0)\n is the same as calling \njohn = BankAccount(john, 1, 1000.0)\n; the \njohn\n that's passed in is also made the result.\n\n\nThis is why when we call \n__init__\n, we initialize objects by saying things like \nself.id = id\n. Remember, since \nself\n is the instance, this is equivalent to saying \njohn.id = id\n, which is the same as \njohn.id= 1\n. Similarly, \nself.balance = balance\n is the same as \njohn.balance = 1000.0\n. After these two lines, we consider the \nBankAccount\n object \"initialized\" and ready for use.\n\n\nBe careful what you \n__init__\n\n\nAfter \n__init__\n has finished, the caller can rightly assume that the object is ready to use. That is, after \njohn = BankAccount(1, 1000.0)\n, we can start making \ndeposit\n and \nwithdraw\n calls on \njohn\n; \njohn\n is a \nfully-initialized\n object.\n\n\nInheritance\n\n\nWhile Object-oriented Programming is useful as a modeling tool, it truly gains power when the concept of \ninheritance\n is introduced. \nInheritance\n is the process by which a \"child\" class \nderives\n the data and behavior of a \"parent\" class. An example will definitely help us here.\n\n\nImagine we run a car dealership. We sell all types of vehicles, from motorcycles to trucks. We set ourselves apart from the competition by our prices. Specifically, how we determine the price of a vehicle on our lot: $5,000 x number of wheels a vehicle has. We love buying back our vehicles as well. We offer a flat rate - 10% of the miles driven on the vehicle. For trucks, that rate is $10,000. For cars, $8,000. For motorcycles, $4,000.\n\n\nIf we wanted to create a sales system for our dealership using Object-oriented techniques, how would we do so? What would the objects be? We might have a \nSale\n class, a \nCustomer\n class, an \nInventory\n class, and so forth, but we'd almost certainly have a \nCar\n, \nTruck\n, and \nMotorcycle\n class.\n\n\nWhat would these classes look like? Using what we've learned, here's a possible implementation of the \nCar\n class:\n\n\nclass Car(object):\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n\n    def sale_price(self):\n        if self.sold_on is not None:\n            return 0.0  # Already sold\n        return 5000.0 * self.wheels\n\n    def purchase_price(self):\n        if self.sold_on is None:\n            return 0.0  # Not yet sold\n        return 8000 - (.10 * self.miles)\n\n\n\n\nOK, that looks pretty reasonable. Of course, we would likely have a number of other methods on the class, but I've shown two of particular interest to us: \nsale_price\n and \npurchase_price\n. We'll see why these are important in a bit.\n\n\nNow that we've got the \nCar\n class, perhaps we should create a \nTruck\n class? Let's follow the same pattern we did for car:\n\n\nclass Truck(object):\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n\n    def sale_price(self):\n        if self.sold_on is not None:\n            return 0.0  # Already sold\n        return 5000.0 * self.wheels\n\n    def purchase_price(self):\n        if self.sold_on is None:\n            return 0.0  # Not yet sold\n        return 10000 - (.10 * self.miles)\n\n\n\n\nWow. That's \nalmost\n identical to the car class. One of the most important rules of programming (in general, not just when dealing with objects) is \"DRY\" or \"\nD\non't \nR\nepeat \nY\nourself. We've definitely repeated ourselves here. In fact, the \nCar\n and \nTruck\n classes differ only by a single character (aside from comments).\n\n\nSo what gives? Where did we go wrong? Our main problem is that we raced straight to the concrete: \nCar\n and \nTruck\n are real things, tangible objects that make intuitive sense as classes. However, they share so much data and functionality in common that it seems there must be an \nabstraction\n we can introduce here. Indeed there is: the notion of \nVehicle\n.\n\n\nAbstract Classes\n\n\nA \nVehicle\n is not a real-world object. Rather, it is a \nconcept\n that some real-world objects (like cars, trucks, and motorcycles) embody. We would like to use the fact that each of these objects can be considered a vehicle to remove repeated code. We can do that by creating a \nVehicle\n class:\n\n\nclass Vehicle(object):\n    base_sale_price = 0\n\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n\n\n    def sale_price(self):\n        if self.sold_on is not None:\n            return 0.0  # Already sold\n        return 5000.0 * self.wheels\n\n    def purchase_price(self):\n        if self.sold_on is None:\n            return 0.0  # Not yet sold\n        return self.base_sale_price - (.10 * self.miles)\n\n\n\n\nNow we can make the \nCar\n and \nTruck\n class \ninherit\n from the \nVehicle\n class by replacing \nobject\n in the line class \nCar(object)\n. The class in parenthesis is the class that is inherited from (\nobject\n essentially means \"no inheritance\". We'll discuss exactly why we write that in a bit).\n\n\nWe can now define \nCar\n and \nTruck\n in a very straightforward way:\n\n\nclass Car(Vehicle):\n\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n        self.base_sale_price = 8000\n\n\nclass Truck(Vehicle):\n\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n        self.base_sale_price = 10000\n\n\n\n\nObject\n\n\nConvert dict to object\n\n\nclass Struct:\n    def __init__(self, **entries):\n        self.__dict__.update(entries)\n\n\n\n\nThen, you can use\n\n\n args = {'a': 1, 'b': 2}\n\n s = Struct(**args)\n\n s\n\n __main__.Struct instance at 0x01D6A738 \n\n\n s.a\n1\n\n s.b\n2\n\n\n\n\nSuggested Readings\n\n\n\n\nImprove Your Python: Python Classes and Object Oriented Programming\n\n\nstackoverflow, Convert Python dict to object?\n\n\nWhy are Python's 'private' methods not actually private?", 
            "title": "Classes and Objects"
        }, 
        {
            "location": "/oop/#object-oriented-programming", 
            "text": "Python has been an object-oriented language since it existed. Because of this, creating and using classes and objects are downright easy. This chapter helps you become an expert in using Python's object-oriented programming support.  If you do not have any previous experience with object-oriented (OO) programming, you may want to consult an introductory course on it or at least a tutorial of some sort so that you have a grasp of the basic concepts.", 
            "title": "Object Oriented Programming"
        }, 
        {
            "location": "/oop/#classes-and-objects", 
            "text": "Classes can be thought of as blueprints for creating objects. When I define a  BankAccount  class using the class keyword, I haven't actually created a bank account. Instead, what I've created is a sort of instruction manual for constructing \"bank account\" objects. Let's look at the following example code:  class BankAccount:\n    id = None\n    balance = 0\n\n    def __init__(self, id, balance=0):\n        self.id = id\n        self.balance = balance\n\n    def __get_balance(self):\n        return self.balance\n\n    def withdraw(self, amount):\n        self.balance = self.balance - amount\n\n    def deposit(self, amount):\n        self.balance = self.balance + amount\n\njohn = BankAccount(1, 1000.0)\njohn.withdraw(100.0)  The  class BankAccount  line  does not  create a new bank account. That is, just because we've  defined  a  BankAcount  doesn't mean we've  created  on; we've merely outlined the  blueprint  to create a  BankAccount  object. To do so, we call the class's  __init__  method with the proper number of arguments (minus  self , which we'll get to in a moment)  So, to use the \"blueprint\" that we crated by defining the  class BankAccount  (which is used to create  BankAccount  objects), we call the class name almost as if it were a function:  john = BankAccount(1, 1000.0) . This line simple say \"use the  BankAccount  blueprint to create me a new object, which I'll refer to as  john \".  The  john   object , known as an  instance , is the realized version of the  BankAccount   class . Before we called  BankAccount() , no  BankAccount  object existed. We can, of course, create as many  BankAccount  objects as we'd like. There is still, however, only one  BankAccount   class , regardless of how many  instances  of the class we create.", 
            "title": "Classes and Objects"
        }, 
        {
            "location": "/oop/#self", 
            "text": "So what's with that  self  parameter to all of the  BankAccount  methods? What is it? Why, it's the instance, of course! Put another way, a method like withdraw defines the instructions for withdrawing money from some abstract customer's account. Calling  john.withdraw(100)  puts those instructions to use on the  john  instance.  So when we say def  withdraw(self, amount) :, we're saying, \"here's how you withdraw money from a  BankAccount  object (which we'll call  self ) and a dollar figure (which we'll call  amount ).  self  is the  instance  of the  BankAccount  that  withdraw  is being called on. That's not me making analogies, either.  john.withdraw(100.0)  is just shorthand for  BankAccount.withdraw(john, 100.0) , which is perfectly valid (if not often seen) code.", 
            "title": "self"
        }, 
        {
            "location": "/oop/#constructors-__init__", 
            "text": "self  may make sense for other methods, but what about  __init__ ? When we call  __init__ , we're in the process of creating an object, so how can there already be a  self ? Python allows us to extend the  self  pattern to when objects are constructed as well, even though it doesn't  exactly  fit. Just imagine that  john = (1, 1000.0)  is the same as calling  john = BankAccount(john, 1, 1000.0) ; the  john  that's passed in is also made the result.  This is why when we call  __init__ , we initialize objects by saying things like  self.id = id . Remember, since  self  is the instance, this is equivalent to saying  john.id = id , which is the same as  john.id= 1 . Similarly,  self.balance = balance  is the same as  john.balance = 1000.0 . After these two lines, we consider the  BankAccount  object \"initialized\" and ready for use.", 
            "title": "Constructors: __init__"
        }, 
        {
            "location": "/oop/#be-careful-what-you-__init__", 
            "text": "After  __init__  has finished, the caller can rightly assume that the object is ready to use. That is, after  john = BankAccount(1, 1000.0) , we can start making  deposit  and  withdraw  calls on  john ;  john  is a  fully-initialized  object.", 
            "title": "Be careful what you __init__"
        }, 
        {
            "location": "/oop/#inheritance", 
            "text": "While Object-oriented Programming is useful as a modeling tool, it truly gains power when the concept of  inheritance  is introduced.  Inheritance  is the process by which a \"child\" class  derives  the data and behavior of a \"parent\" class. An example will definitely help us here.  Imagine we run a car dealership. We sell all types of vehicles, from motorcycles to trucks. We set ourselves apart from the competition by our prices. Specifically, how we determine the price of a vehicle on our lot: $5,000 x number of wheels a vehicle has. We love buying back our vehicles as well. We offer a flat rate - 10% of the miles driven on the vehicle. For trucks, that rate is $10,000. For cars, $8,000. For motorcycles, $4,000.  If we wanted to create a sales system for our dealership using Object-oriented techniques, how would we do so? What would the objects be? We might have a  Sale  class, a  Customer  class, an  Inventory  class, and so forth, but we'd almost certainly have a  Car ,  Truck , and  Motorcycle  class.  What would these classes look like? Using what we've learned, here's a possible implementation of the  Car  class:  class Car(object):\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n\n    def sale_price(self):\n        if self.sold_on is not None:\n            return 0.0  # Already sold\n        return 5000.0 * self.wheels\n\n    def purchase_price(self):\n        if self.sold_on is None:\n            return 0.0  # Not yet sold\n        return 8000 - (.10 * self.miles)  OK, that looks pretty reasonable. Of course, we would likely have a number of other methods on the class, but I've shown two of particular interest to us:  sale_price  and  purchase_price . We'll see why these are important in a bit.  Now that we've got the  Car  class, perhaps we should create a  Truck  class? Let's follow the same pattern we did for car:  class Truck(object):\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n\n    def sale_price(self):\n        if self.sold_on is not None:\n            return 0.0  # Already sold\n        return 5000.0 * self.wheels\n\n    def purchase_price(self):\n        if self.sold_on is None:\n            return 0.0  # Not yet sold\n        return 10000 - (.10 * self.miles)  Wow. That's  almost  identical to the car class. One of the most important rules of programming (in general, not just when dealing with objects) is \"DRY\" or \" D on't  R epeat  Y ourself. We've definitely repeated ourselves here. In fact, the  Car  and  Truck  classes differ only by a single character (aside from comments).  So what gives? Where did we go wrong? Our main problem is that we raced straight to the concrete:  Car  and  Truck  are real things, tangible objects that make intuitive sense as classes. However, they share so much data and functionality in common that it seems there must be an  abstraction  we can introduce here. Indeed there is: the notion of  Vehicle .", 
            "title": "Inheritance"
        }, 
        {
            "location": "/oop/#abstract-classes", 
            "text": "A  Vehicle  is not a real-world object. Rather, it is a  concept  that some real-world objects (like cars, trucks, and motorcycles) embody. We would like to use the fact that each of these objects can be considered a vehicle to remove repeated code. We can do that by creating a  Vehicle  class:  class Vehicle(object):\n    base_sale_price = 0\n\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n\n\n    def sale_price(self):\n        if self.sold_on is not None:\n            return 0.0  # Already sold\n        return 5000.0 * self.wheels\n\n    def purchase_price(self):\n        if self.sold_on is None:\n            return 0.0  # Not yet sold\n        return self.base_sale_price - (.10 * self.miles)  Now we can make the  Car  and  Truck  class  inherit  from the  Vehicle  class by replacing  object  in the line class  Car(object) . The class in parenthesis is the class that is inherited from ( object  essentially means \"no inheritance\". We'll discuss exactly why we write that in a bit).  We can now define  Car  and  Truck  in a very straightforward way:  class Car(Vehicle):\n\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n        self.base_sale_price = 8000\n\n\nclass Truck(Vehicle):\n\n    def __init__(self, wheels, miles, make, model, year, sold_on):\n        self.wheels = wheels\n        self.miles = miles\n        self.make = make\n        self.model = model\n        self.year = year\n        self.sold_on = sold_on\n        self.base_sale_price = 10000", 
            "title": "Abstract Classes"
        }, 
        {
            "location": "/oop/#object", 
            "text": "Convert dict to object  class Struct:\n    def __init__(self, **entries):\n        self.__dict__.update(entries)  Then, you can use   args = {'a': 1, 'b': 2}  s = Struct(**args)  s  __main__.Struct instance at 0x01D6A738    s.a\n1  s.b\n2", 
            "title": "Object"
        }, 
        {
            "location": "/oop/#suggested-readings", 
            "text": "Improve Your Python: Python Classes and Object Oriented Programming  stackoverflow, Convert Python dict to object?  Why are Python's 'private' methods not actually private?", 
            "title": "Suggested Readings"
        }, 
        {
            "location": "/metaclasses/", 
            "text": "Metaclasses\n\n\nPython, Classes, and Objects\n\n\nMost readers are aware that Python is an object-oriented language.  By\nobject-oriented, we mean that Python can define \nclasses\n, which bundle\n\ndata\n and \nfunctionality\n into one entity.  For example, we may\ncreate a class \nIntContainer\n which stores an integer and allows\ncertain operations to be performed:\n\n\nclass IntContainer(object):\n    def __init__(self, i):\n        self.i = int(i)\n\n    def add_one(self):\n        self.i += 1\n\n\n\n\nic = IntContainer(2)\nic.add_one()\nprint(ic.i)\n\n\n\n\n3\n\n\n\nThis is a bit of a silly example, but shows the fundamental nature of\nclasses: their ability to bundle data and operations into a single\n\nobject\n, which leads to cleaner, more manageable, and more adaptable code.\nAdditionally, classes can inherit properties from parents and add or\nspecialize attributes and methods.  This \nobject-oriented\n\napproach to programming can be very intuitive and powerful.\n\n\nWhat many do not realize, though, is that quite literally\n\neverything\n\nin the Python language is an object.\n\n\n\n\n\nFor example, integers are simply instances of\nthe built-in \nint\n type:\n\n\nprint type(1)\n\n\n\n\ntype 'int'\n\n\n\n\nTo emphasize that the \nint\n type really is an object, let's derive from it\nand specialize the \n__add__\n method (which is the machinery underneath\nthe \n+\n operator):\n\n\n(Note: We'll used the\n \nsuper\n \nsyntax to call methods from the parent class: if you're unfamiliar with this, take a look at\n\n\nthis StackOverflow question\n).\n\n\nclass MyInt(int):\n    def __add__(self, other):\n        print \nspecializing addition\n\n        return super(MyInt, self).__add__(other)\n\ni = MyInt(2)\nprint(i + 2)\n\n\n\n\nspecializing addition\n4\n\n\n\nUsing the \n+\n operator on our derived type goes through our \n__add__\n\nmethod, as expected.\nWe see that \nint\n really is an object that can be subclassed and extended\njust like user-defined classes.  The same is true\nof \nfloat\ns, \nlist\ns, \ntuple\ns, and everything else in the Python\nlanguage.  They're all objects.\n\n\nDown the Rabbit Hole: Classes as Objects\n\n\nWe said above that \neverything\n in python is an object: it turns out that this\nis true of \nclasses themselves\n.  Let's look at an example.\n\n\nWe'll start by defining a class that does nothing\n\n\nclass DoNothing(object):\n    pass\n\n\n\n\nIf we instantiate this, we can use the \ntype\n operator to see the type\nof object that it is:\n\n\nd = DoNothing()\ntype(d)\n\n\n\n\n__main__.DoNothing\n\n\n\nWe see that our variable \nd\n is an instance of the class\n\n__main__.DoNothing\n.\n\n\nWe can do this similarly for built-in  types:\n\n\nL = [1, 2, 3]\ntype(L)\n\n\n\n\nlist\n\n\n\nA list is, as you may expect, an object of type \nlist\n.\n\n\nBut let's take this a step further: what is the type\nof \nDoNothing\n itself?\n\n\ntype(DoNothing)\n\n\n\n\ntype\n\n\n\nThe type of \nDoNothing\n is \ntype\n.  This tells us that the \nclass\n\n\nDoNothing\n is itself an object, and that object is of type \ntype\n.\n\n\nIt turns out that this is the same for built-in datatypes:\n\n\ntype(tuple), type(list), type(int), type(float)\n\n\n\n\n(type, type, type, type)\n\n\n\nWhat this shows is that in Python, \nclasses are objects\n, and they are objects of\ntype \ntype\n.  \ntype\n is a \nmetaclass\n: a class which instantiates classes.\nAll \nnew-style classes\n\nin Python are instances of the \ntype\n metaclass, including \ntype\n itself:\n\n\ntype(type)\n\n\n\n\ntype\n\n\n\nYes, you read that correctly:\nthe type of \ntype\n is \ntype\n.  In other words, \ntype\n is \nan\ninstance of itself\n.  This sort of circularity cannot (to my knowledge)\nbe duplicated in pure Python, and the behavior is created through a bit of a\nhack at the implementation level of Python.\n\n\nMetaprogramming: Creating Classes on the Fly\n\n\nNow that we've stepped back and considered the fact that classes in Python\nare simply objects like everything else, we can think about what is known\nas \nmetaprogramming\n.  You're probably used to creating functions which\nreturn objects.  We can think of these functions as an object factory: they\ntake some arguments, create an object, and return it.  Here is a simple example\nof a function which creates an \nint\n object:\n\n\ndef int_factory(s):\n    i = int(s)\n    return i\n\ni = int_factory('100')\nprint(i)\n\n\n\n\n100\n\n\n\nThis is overly-simplistic, but any function you write in the course\nof a normal program can be boiled down to this: take some arguments,\ndo some operations, and create \n return an object.\nWith the above discussion in mind, though, there's nothing to stop\nus from creating an object of type \ntype\n (that is, a class), \nand returning that instead -- this is a \nmetafunction:\n\n\ndef class_factory():\n    class Foo(object):\n        pass\n    return Foo\n\nF = class_factory()\nf = F()\nprint(type(f))\n\n\n\n\nclass '__main__.Foo'\n\n\n\n\nJust as the function \nint_factory\n constructs an returns an instance of\n\nint\n,\nthe function \nclass_factory\n constructs and returns an instance of \ntype\n:\nthat is, a class.\n\n\nBut the above construction is a bit awkward: especially if we were going to do some\nmore complicated logic when constructing \nFoo\n, it would be nice to avoid all the\nnested indentations and define the class in a more dynamic way.\nWe can accomplish this by instantiating \nFoo\n from \ntype\n directly:\n\n\ndef class_factory():\n    return type('Foo', (), {})\n\nF = class_factory()\nf = F()\nprint(type(f))\n\n\n\n\nclass '__main__.Foo'\n\n\n\n\nIn fact, the construct\n\n\nclass MyClass(object):\n    pass\n\n\n\n\nis identical to the construct\n\n\nMyClass = type('MyClass', (), {})\n\n\n\n\nMyClass\n is an instance of type \ntype\n, and that can be seen\nexplicitly in the second version of the definition.\nA potential confusion arises from the more common use of \ntype\n as\na function to determine the type of an object, but you should strive\nto separate these two uses of the keyword in your mind:\nhere \ntype\n is a class (more precisely, a \nmetaclass\n),\nand \nMyClass\n is an instance of \ntype\n.\n\n\nThe arguments to the \ntype\n constructor are:\ntype(name, bases, dct)\n- \nname\n is a string giving the name of the class to be constructed\n- \nbases\n is a tuple giving the parent classes of the class to be constructed\n- \ndct\n is a dictionary of the attributes and methods of the class to be constructed\n\n\nSo, for example, the following two pieces of code have identical results:\n\n\nclass Foo(object):\n    i = 4\n\nclass Bar(Foo):\n    def get_i(self):\n        return self.i\n\nb = Bar()\nprint(b.get_i())\n\n\n\n\n4\n\n\n\nFoo = type('Foo', (), dict(i=4))\n\nBar = type('Bar', (Foo,), dict(get_i = lambda self: self.i))\n\nb = Bar()\nprint(b.get_i())\n\n\n\n\n4\n\n\n\nThis perhaps seems a bit over-complicated in the case of this contrived\nexample, but it can be very powerful as a means of dynamically creating\nnew classes on-the-fly.\n\n\nMaking Things Interesting: Custom Metaclasses\n\n\nNow things get really fun.  Just as we can inherit from and extend a class we've\ncreated, we can also inherit from and extend the \ntype\n metaclass, and create\ncustom behavior in our metaclass.\n\n\nExample 1: Modifying Attributes\n\n\nLet's use a simple example where we want to create an API in which the user can\ncreate a set of interfaces which contain a file object.  Each interface should\nhave a unique string ID, and contain an open file object.  The user could then write\nspecialized methods to accomplish certain tasks.  There are certainly good\nways to do this without delving into metaclasses, but such a simple example will\n(hopefully) elucidate what's going on.\n\n\nFirst we'll create our interface meta class, deriving from \ntype\n:\n\n\nclass InterfaceMeta(type):\n    def __new__(cls, name, parents, dct):\n        # create a class_id if it's not specified\n        if 'class_id' not in dct:\n            dct['class_id'] = name.lower()\n\n        # open the specified file for writing\n        if 'file' in dct:\n            filename = dct['file']\n            dct['file'] = open(filename, 'w')\n\n        # we need to call type.__new__ to complete the initialization\n        return super(InterfaceMeta, cls).__new__(cls, name, parents, dct)\n\n\n\n\nNotice that we've modified the input dictionary (the attributes and\nmethods of the class) to add a class id if it's not present, and to\nreplace the filename with a file object pointing to that file name.\n\n\nNow we'll use our \nInterfaceMeta\n class to construct and instantiate\nan Interface object:\n\n\nInterface = InterfaceMeta('Interface', (), dict(file='tmp.txt'))\n\nprint(Interface.class_id)\nprint(Interface.file)\n\n\n\n\ninterface\n\nopen file 'tmp.txt', mode 'w' at 0x21b8810\n\n\n\n\nThis behaves as we'd expect: the \nclass_id\n class variable is created,\nand the \nfile\n class variable is replaced with an open file object.\nStill, the creation of the \nInterface\n class\nusing \nInterfaceMeta\n directly is a bit clunky and difficult to read.\nThis is where \n__metaclass__\n comes in\nand steals the show.  We can accomplish the same thing by\ndefining \nInterface\n this way:\n\n\nclass Interface(object):\n    __metaclass__ = InterfaceMeta\n    file = 'tmp.txt'\n\nprint(Interface.class_id)\nprint(Interface.file)\n\n\n\n\ninterface\n\nopen file 'tmp.txt', mode 'w' at 0x21b8ae0\n\n\n\n\nby defining the \n__metaclass__\n attribute of the class, we've told the\nclass that it should be constructed using \nInterfaceMeta\n rather than\nusing \ntype\n.  To make this more definite, observe that the type of\n\nInterface\n is now \nInterfaceMeta\n:\n\n\ntype(Interface)\n\n\n\n\n__main__.InterfaceMeta\n\n\n\nFurthermore, any class derived from \nInterface\n will now be constructed\nusing the same metaclass:\n\n\nclass UserInterface(Interface):\n    file = 'foo.txt'\n\nprint(UserInterface.file)\nprint(UserInterface.class_id)\n\n\n\n\nopen file 'foo.txt', mode 'w' at 0x21b8c00\n\nuserinterface\n\n\n\nThis simple example shows how metaclasses can be used to create powerful and\nflexible APIs for projects.  For example, the\n\nDjango project\n\nmakes use of these sorts of constructions to allow concise declarations\nof very powerful extensions to their basic classes.\n\n\nExample 2: Registering Subclasses\n\n\nAnother possible use of a metaclass is to automatically register all\nsubclasses derived from a given base class.  For example, you may have\na basic interface to a database and wish for the user to be able to\ndefine their own interfaces, which are automatically stored in a master registry.\n\n\nYou might proceed this way:\n\n\nclass DBInterfaceMeta(type):\n    # we use __init__ rather than __new__ here because we want\n    # to modify attributes of the class *after* they have been\n    # created\n    def __init__(cls, name, bases, dct):\n        if not hasattr(cls, 'registry'):\n            # this is the base class.  Create an empty registry\n            cls.registry = {}\n        else:\n            # this is a derived class.  Add cls to the registry\n            interface_id = name.lower()\n            cls.registry[interface_id] = cls\n\n        super(DBInterfaceMeta, cls).__init__(name, bases, dct)\n\n\n\n\nOur metaclass simply adds a \nregistry\n dictionary if it's not already\npresent, and adds the new class to the registry if the registry is already\nthere.  Let's see how this works:\n\n\nclass DBInterface(object):\n    __metaclass__ = DBInterfaceMeta\n\nprint(DBInterface.registry)\n\n\n\n\n{}\n\n\n\nNow let's create some subclasses, and double-check that they're added to\nthe registry:\n\n\nclass FirstInterface(DBInterface):\n    pass\n\nclass SecondInterface(DBInterface):\n    pass\n\nclass SecondInterfaceModified(SecondInterface):\n    pass\n\nprint(DBInterface.registry)\n\n\n\n\n{'firstinterface': \nclass '__main__.FirstInterface'\n, 'secondinterface': \nclass '__main__.SecondInterface'\n, 'secondinterfacemodified': \nclass '__main__.SecondInterfaceModified'\n}\n\n\n\nIt works as expected!  This could be used in conjunction with\na function that chooses implementations from the registry,\nand any user-defined \nInterface\n-derived objects would be\nautomatically accounted for, without the user having to remember\nto manually register the new types.\n\n\nConclusion: When Should You Use Metaclasses?\n\n\nI've gone through some examples of what metaclasses are, and some ideas \nabout how they might be used to create very powerful and flexible APIs. \nAlthough metaclasses are in the background of everything you do in Python,\nthe average coder rarely has to think about them.\n\n\nBut the question remains: when should you think about using custom\nmetaclasses in your project?  It's a complicated question, but\nthere's a quotation floating around the web\nthat addresses it quite succinctly:\n\n\n\n\nMetaclasses are deeper magic than 99% of users should ever worry about.\nIf you wonder whether you need them, you don\u2019t (the people who actually\nneed them know with certainty that they need them, and don\u2019t need an\nexplanation about why).\n\n\n\u2013 Tim Peters\n\n\n\n\nIn a way, this is a very unsatisfying answer: it's a bit reminiscent of\nthe wistful and cliched explanation of the border between attraction\nand love: \"well, you just... know!\"\n\n\nBut I think Tim is right: in general,\nI've found that most tasks in Python that can be accomplished through\nuse of custom metaclasses can also be accomplished more cleanly and with\nmore clarity by other means.  As programmers, we should always be careful\nto avoid being clever for the sake of cleverness alone, though\nit is admittedly an ever-present temptation.\n\n\nI personally spent six years doing science with Python, writing code\nnearly on a daily basis, before I found a problem for which metaclasses\nwere the natural solution.  And it turns out Tim was right:\n\n\nI just knew.", 
            "title": "Metaclasses"
        }, 
        {
            "location": "/metaclasses/#metaclasses", 
            "text": "", 
            "title": "Metaclasses"
        }, 
        {
            "location": "/metaclasses/#python-classes-and-objects", 
            "text": "Most readers are aware that Python is an object-oriented language.  By\nobject-oriented, we mean that Python can define  classes , which bundle data  and  functionality  into one entity.  For example, we may\ncreate a class  IntContainer  which stores an integer and allows\ncertain operations to be performed:  class IntContainer(object):\n    def __init__(self, i):\n        self.i = int(i)\n\n    def add_one(self):\n        self.i += 1  ic = IntContainer(2)\nic.add_one()\nprint(ic.i)  3  This is a bit of a silly example, but shows the fundamental nature of\nclasses: their ability to bundle data and operations into a single object , which leads to cleaner, more manageable, and more adaptable code.\nAdditionally, classes can inherit properties from parents and add or\nspecialize attributes and methods.  This  object-oriented \napproach to programming can be very intuitive and powerful.  What many do not realize, though, is that quite literally everything \nin the Python language is an object.   For example, integers are simply instances of\nthe built-in  int  type:  print type(1)  type 'int'   To emphasize that the  int  type really is an object, let's derive from it\nand specialize the  __add__  method (which is the machinery underneath\nthe  +  operator):  (Note: We'll used the   super   syntax to call methods from the parent class: if you're unfamiliar with this, take a look at  this StackOverflow question ).  class MyInt(int):\n    def __add__(self, other):\n        print  specializing addition \n        return super(MyInt, self).__add__(other)\n\ni = MyInt(2)\nprint(i + 2)  specializing addition\n4  Using the  +  operator on our derived type goes through our  __add__ \nmethod, as expected.\nWe see that  int  really is an object that can be subclassed and extended\njust like user-defined classes.  The same is true\nof  float s,  list s,  tuple s, and everything else in the Python\nlanguage.  They're all objects.", 
            "title": "Python, Classes, and Objects"
        }, 
        {
            "location": "/metaclasses/#down-the-rabbit-hole-classes-as-objects", 
            "text": "We said above that  everything  in python is an object: it turns out that this\nis true of  classes themselves .  Let's look at an example.  We'll start by defining a class that does nothing  class DoNothing(object):\n    pass  If we instantiate this, we can use the  type  operator to see the type\nof object that it is:  d = DoNothing()\ntype(d)  __main__.DoNothing  We see that our variable  d  is an instance of the class __main__.DoNothing .  We can do this similarly for built-in  types:  L = [1, 2, 3]\ntype(L)  list  A list is, as you may expect, an object of type  list .  But let's take this a step further: what is the type\nof  DoNothing  itself?  type(DoNothing)  type  The type of  DoNothing  is  type .  This tells us that the  class  DoNothing  is itself an object, and that object is of type  type .  It turns out that this is the same for built-in datatypes:  type(tuple), type(list), type(int), type(float)  (type, type, type, type)  What this shows is that in Python,  classes are objects , and they are objects of\ntype  type .   type  is a  metaclass : a class which instantiates classes.\nAll  new-style classes \nin Python are instances of the  type  metaclass, including  type  itself:  type(type)  type  Yes, you read that correctly:\nthe type of  type  is  type .  In other words,  type  is  an\ninstance of itself .  This sort of circularity cannot (to my knowledge)\nbe duplicated in pure Python, and the behavior is created through a bit of a\nhack at the implementation level of Python.", 
            "title": "Down the Rabbit Hole: Classes as Objects"
        }, 
        {
            "location": "/metaclasses/#metaprogramming-creating-classes-on-the-fly", 
            "text": "Now that we've stepped back and considered the fact that classes in Python\nare simply objects like everything else, we can think about what is known\nas  metaprogramming .  You're probably used to creating functions which\nreturn objects.  We can think of these functions as an object factory: they\ntake some arguments, create an object, and return it.  Here is a simple example\nof a function which creates an  int  object:  def int_factory(s):\n    i = int(s)\n    return i\n\ni = int_factory('100')\nprint(i)  100  This is overly-simplistic, but any function you write in the course\nof a normal program can be boiled down to this: take some arguments,\ndo some operations, and create   return an object.\nWith the above discussion in mind, though, there's nothing to stop\nus from creating an object of type  type  (that is, a class), \nand returning that instead -- this is a  metafunction:  def class_factory():\n    class Foo(object):\n        pass\n    return Foo\n\nF = class_factory()\nf = F()\nprint(type(f))  class '__main__.Foo'   Just as the function  int_factory  constructs an returns an instance of int ,\nthe function  class_factory  constructs and returns an instance of  type :\nthat is, a class.  But the above construction is a bit awkward: especially if we were going to do some\nmore complicated logic when constructing  Foo , it would be nice to avoid all the\nnested indentations and define the class in a more dynamic way.\nWe can accomplish this by instantiating  Foo  from  type  directly:  def class_factory():\n    return type('Foo', (), {})\n\nF = class_factory()\nf = F()\nprint(type(f))  class '__main__.Foo'   In fact, the construct  class MyClass(object):\n    pass  is identical to the construct  MyClass = type('MyClass', (), {})  MyClass  is an instance of type  type , and that can be seen\nexplicitly in the second version of the definition.\nA potential confusion arises from the more common use of  type  as\na function to determine the type of an object, but you should strive\nto separate these two uses of the keyword in your mind:\nhere  type  is a class (more precisely, a  metaclass ),\nand  MyClass  is an instance of  type .  The arguments to the  type  constructor are:\ntype(name, bases, dct)\n-  name  is a string giving the name of the class to be constructed\n-  bases  is a tuple giving the parent classes of the class to be constructed\n-  dct  is a dictionary of the attributes and methods of the class to be constructed  So, for example, the following two pieces of code have identical results:  class Foo(object):\n    i = 4\n\nclass Bar(Foo):\n    def get_i(self):\n        return self.i\n\nb = Bar()\nprint(b.get_i())  4  Foo = type('Foo', (), dict(i=4))\n\nBar = type('Bar', (Foo,), dict(get_i = lambda self: self.i))\n\nb = Bar()\nprint(b.get_i())  4  This perhaps seems a bit over-complicated in the case of this contrived\nexample, but it can be very powerful as a means of dynamically creating\nnew classes on-the-fly.", 
            "title": "Metaprogramming: Creating Classes on the Fly"
        }, 
        {
            "location": "/metaclasses/#making-things-interesting-custom-metaclasses", 
            "text": "Now things get really fun.  Just as we can inherit from and extend a class we've\ncreated, we can also inherit from and extend the  type  metaclass, and create\ncustom behavior in our metaclass.", 
            "title": "Making Things Interesting: Custom Metaclasses"
        }, 
        {
            "location": "/metaclasses/#example-1-modifying-attributes", 
            "text": "Let's use a simple example where we want to create an API in which the user can\ncreate a set of interfaces which contain a file object.  Each interface should\nhave a unique string ID, and contain an open file object.  The user could then write\nspecialized methods to accomplish certain tasks.  There are certainly good\nways to do this without delving into metaclasses, but such a simple example will\n(hopefully) elucidate what's going on.  First we'll create our interface meta class, deriving from  type :  class InterfaceMeta(type):\n    def __new__(cls, name, parents, dct):\n        # create a class_id if it's not specified\n        if 'class_id' not in dct:\n            dct['class_id'] = name.lower()\n\n        # open the specified file for writing\n        if 'file' in dct:\n            filename = dct['file']\n            dct['file'] = open(filename, 'w')\n\n        # we need to call type.__new__ to complete the initialization\n        return super(InterfaceMeta, cls).__new__(cls, name, parents, dct)  Notice that we've modified the input dictionary (the attributes and\nmethods of the class) to add a class id if it's not present, and to\nreplace the filename with a file object pointing to that file name.  Now we'll use our  InterfaceMeta  class to construct and instantiate\nan Interface object:  Interface = InterfaceMeta('Interface', (), dict(file='tmp.txt'))\n\nprint(Interface.class_id)\nprint(Interface.file)  interface open file 'tmp.txt', mode 'w' at 0x21b8810   This behaves as we'd expect: the  class_id  class variable is created,\nand the  file  class variable is replaced with an open file object.\nStill, the creation of the  Interface  class\nusing  InterfaceMeta  directly is a bit clunky and difficult to read.\nThis is where  __metaclass__  comes in\nand steals the show.  We can accomplish the same thing by\ndefining  Interface  this way:  class Interface(object):\n    __metaclass__ = InterfaceMeta\n    file = 'tmp.txt'\n\nprint(Interface.class_id)\nprint(Interface.file)  interface open file 'tmp.txt', mode 'w' at 0x21b8ae0   by defining the  __metaclass__  attribute of the class, we've told the\nclass that it should be constructed using  InterfaceMeta  rather than\nusing  type .  To make this more definite, observe that the type of Interface  is now  InterfaceMeta :  type(Interface)  __main__.InterfaceMeta  Furthermore, any class derived from  Interface  will now be constructed\nusing the same metaclass:  class UserInterface(Interface):\n    file = 'foo.txt'\n\nprint(UserInterface.file)\nprint(UserInterface.class_id)  open file 'foo.txt', mode 'w' at 0x21b8c00 \nuserinterface  This simple example shows how metaclasses can be used to create powerful and\nflexible APIs for projects.  For example, the Django project \nmakes use of these sorts of constructions to allow concise declarations\nof very powerful extensions to their basic classes.", 
            "title": "Example 1: Modifying Attributes"
        }, 
        {
            "location": "/metaclasses/#example-2-registering-subclasses", 
            "text": "Another possible use of a metaclass is to automatically register all\nsubclasses derived from a given base class.  For example, you may have\na basic interface to a database and wish for the user to be able to\ndefine their own interfaces, which are automatically stored in a master registry.  You might proceed this way:  class DBInterfaceMeta(type):\n    # we use __init__ rather than __new__ here because we want\n    # to modify attributes of the class *after* they have been\n    # created\n    def __init__(cls, name, bases, dct):\n        if not hasattr(cls, 'registry'):\n            # this is the base class.  Create an empty registry\n            cls.registry = {}\n        else:\n            # this is a derived class.  Add cls to the registry\n            interface_id = name.lower()\n            cls.registry[interface_id] = cls\n\n        super(DBInterfaceMeta, cls).__init__(name, bases, dct)  Our metaclass simply adds a  registry  dictionary if it's not already\npresent, and adds the new class to the registry if the registry is already\nthere.  Let's see how this works:  class DBInterface(object):\n    __metaclass__ = DBInterfaceMeta\n\nprint(DBInterface.registry)  {}  Now let's create some subclasses, and double-check that they're added to\nthe registry:  class FirstInterface(DBInterface):\n    pass\n\nclass SecondInterface(DBInterface):\n    pass\n\nclass SecondInterfaceModified(SecondInterface):\n    pass\n\nprint(DBInterface.registry)  {'firstinterface':  class '__main__.FirstInterface' , 'secondinterface':  class '__main__.SecondInterface' , 'secondinterfacemodified':  class '__main__.SecondInterfaceModified' }  It works as expected!  This could be used in conjunction with\na function that chooses implementations from the registry,\nand any user-defined  Interface -derived objects would be\nautomatically accounted for, without the user having to remember\nto manually register the new types.", 
            "title": "Example 2: Registering Subclasses"
        }, 
        {
            "location": "/metaclasses/#conclusion-when-should-you-use-metaclasses", 
            "text": "I've gone through some examples of what metaclasses are, and some ideas \nabout how they might be used to create very powerful and flexible APIs. \nAlthough metaclasses are in the background of everything you do in Python,\nthe average coder rarely has to think about them.  But the question remains: when should you think about using custom\nmetaclasses in your project?  It's a complicated question, but\nthere's a quotation floating around the web\nthat addresses it quite succinctly:   Metaclasses are deeper magic than 99% of users should ever worry about.\nIf you wonder whether you need them, you don\u2019t (the people who actually\nneed them know with certainty that they need them, and don\u2019t need an\nexplanation about why).  \u2013 Tim Peters   In a way, this is a very unsatisfying answer: it's a bit reminiscent of\nthe wistful and cliched explanation of the border between attraction\nand love: \"well, you just... know!\"  But I think Tim is right: in general,\nI've found that most tasks in Python that can be accomplished through\nuse of custom metaclasses can also be accomplished more cleanly and with\nmore clarity by other means.  As programmers, we should always be careful\nto avoid being clever for the sake of cleverness alone, though\nit is admittedly an ever-present temptation.  I personally spent six years doing science with Python, writing code\nnearly on a daily basis, before I found a problem for which metaclasses\nwere the natural solution.  And it turns out Tim was right:  I just knew.", 
            "title": "Conclusion: When Should You Use Metaclasses?"
        }, 
        {
            "location": "/design_patterns/", 
            "text": "Design Patterns\n\n\nSingleton\n\n\nNon-thread-safe\n\n\nPaul Manta's implementation of singletons\n\n\n@Singleton\nclass Foo:\n   def __init__(self):\n       print 'Foo created'\n\nf = Foo() # Error, this isn't how you get the instance of a singleton\n\nf = Foo.Instance() # Good. Being explicit is in line with the Python Zen\ng = Foo.Instance() # Returns already created instance\n\nprint f is g # True\n\nclass Singleton:\n    \n\n    A non-thread-safe helper class to ease implementing singletons.\n    This should be used as a decorator -- not a metaclass -- to the\n    class that should be a singleton.\n\n    The decorated class can define one `__init__` function that\n    takes only the `self` argument. Also, the decorated class cannot be\n    inherited from. Other than that, there are no restrictions that apply\n    to the decorated class.\n\n    To get the singleton instance, use the `Instance` method. Trying\n    to use `__call__` will result in a `TypeError` being raised.\n\n    \n\n\n    def __init__(self, decorated):\n        self._decorated = decorated\n\n    def Instance(self):\n        \n\n        Returns the singleton instance. Upon its first call, it creates a\n        new instance of the decorated class and calls its `__init__` method.\n        On all subsequent calls, the already created instance is returned.\n\n        \n\n        try:\n            return self._instance\n        except AttributeError:\n            self._instance = self._decorated()\n            return self._instance\n\n    def __call__(self):\n        raise TypeError('Singletons must be accessed through `Instance()`.')\n\n    def __instancecheck__(self, inst):\n        return isinstance(inst, self._decorated)\n\n\n\n\nThread safe\n\n\nwerediver's implementation of singletons. A thread safe implementation of singleton pattern in Python. Based on tornado.ioloop.IOLoop.instance() approach.\n\n\nimport threading\n\n# Based on tornado.ioloop.IOLoop.instance() approach.\n# See https://github.com/facebook/tornado\nclass SingletonMixin(object):\n    __singleton_lock = threading.Lock()\n    __singleton_instance = None\n\n    @classmethod\n    def instance(cls):\n        if not cls.__singleton_instance:\n            with cls.__singleton_lock:\n                if not cls.__singleton_instance:\n                    cls.__singleton_instance = cls()\n        return cls.__singleton_instance\n\nclass A(SingletonMixin):\n    pass\n\nclass B(SingletonMixin):\n    pass\n\nif __name__ == '__main__':\n    a, a2 = A.instance(), A.instance()\n    b, b2 = B.instance(), B.instance()\n\n    assert a is a2\n    assert b is b2\n    assert a is not b\n\n    print('a:  %s\\na2: %s' % (a, a2))\n    print('b:  %s\\nb2: %s' % (b, b2))\n\n\n\n\nSuggested Readings\n\n\n\n\nIs there a simple, elegant way to define singletons?", 
            "title": "Design Patterns"
        }, 
        {
            "location": "/design_patterns/#design-patterns", 
            "text": "", 
            "title": "Design Patterns"
        }, 
        {
            "location": "/design_patterns/#singleton", 
            "text": "", 
            "title": "Singleton"
        }, 
        {
            "location": "/design_patterns/#non-thread-safe", 
            "text": "Paul Manta's implementation of singletons  @Singleton\nclass Foo:\n   def __init__(self):\n       print 'Foo created'\n\nf = Foo() # Error, this isn't how you get the instance of a singleton\n\nf = Foo.Instance() # Good. Being explicit is in line with the Python Zen\ng = Foo.Instance() # Returns already created instance\n\nprint f is g # True\n\nclass Singleton:\n     \n    A non-thread-safe helper class to ease implementing singletons.\n    This should be used as a decorator -- not a metaclass -- to the\n    class that should be a singleton.\n\n    The decorated class can define one `__init__` function that\n    takes only the `self` argument. Also, the decorated class cannot be\n    inherited from. Other than that, there are no restrictions that apply\n    to the decorated class.\n\n    To get the singleton instance, use the `Instance` method. Trying\n    to use `__call__` will result in a `TypeError` being raised.\n\n     \n\n    def __init__(self, decorated):\n        self._decorated = decorated\n\n    def Instance(self):\n         \n        Returns the singleton instance. Upon its first call, it creates a\n        new instance of the decorated class and calls its `__init__` method.\n        On all subsequent calls, the already created instance is returned.\n\n         \n        try:\n            return self._instance\n        except AttributeError:\n            self._instance = self._decorated()\n            return self._instance\n\n    def __call__(self):\n        raise TypeError('Singletons must be accessed through `Instance()`.')\n\n    def __instancecheck__(self, inst):\n        return isinstance(inst, self._decorated)", 
            "title": "Non-thread-safe"
        }, 
        {
            "location": "/design_patterns/#thread-safe", 
            "text": "werediver's implementation of singletons. A thread safe implementation of singleton pattern in Python. Based on tornado.ioloop.IOLoop.instance() approach.  import threading\n\n# Based on tornado.ioloop.IOLoop.instance() approach.\n# See https://github.com/facebook/tornado\nclass SingletonMixin(object):\n    __singleton_lock = threading.Lock()\n    __singleton_instance = None\n\n    @classmethod\n    def instance(cls):\n        if not cls.__singleton_instance:\n            with cls.__singleton_lock:\n                if not cls.__singleton_instance:\n                    cls.__singleton_instance = cls()\n        return cls.__singleton_instance\n\nclass A(SingletonMixin):\n    pass\n\nclass B(SingletonMixin):\n    pass\n\nif __name__ == '__main__':\n    a, a2 = A.instance(), A.instance()\n    b, b2 = B.instance(), B.instance()\n\n    assert a is a2\n    assert b is b2\n    assert a is not b\n\n    print('a:  %s\\na2: %s' % (a, a2))\n    print('b:  %s\\nb2: %s' % (b, b2))", 
            "title": "Thread safe"
        }, 
        {
            "location": "/design_patterns/#suggested-readings", 
            "text": "Is there a simple, elegant way to define singletons?", 
            "title": "Suggested Readings"
        }, 
        {
            "location": "/io/", 
            "text": "JSON\n\n\nWrite json file with pretty format and unicode\n\n\nimport json\nimport io\n\ndata = {\n    \nmenu\n: {\n        \nheader\n: \nSample Menu\n,\n        \nitems\n: [\n            {\nid\n: \nOpen\n},\n            {\nid\n: \nOpenNew\n, \nlabel\n: \nOpen New\n},\n            None,\n            {\nid\n: \nHelp\n},\n            {\nid\n: \nAbout\n, \nlabel\n: \nAbout Adobe CVG Viewer...\n}\n        ]\n    }}\n\nwith io.open(\nsample_json.json\n, \nw\n, encoding=\nutf8\n) as f:\n    content = json.dumps(data, indent=4, sort_keys=True, ensure_ascii=False)\n    f.write(unicode(content))\n\n\n\n\nResult\n\n\n{\n    \nmenu\n: {\n        \nheader\n: \nSample Menu\n,\n        \nitems\n: [\n            {\n                \nid\n: \nOpen\n\n            },\n            {\n                \nid\n: \nOpenNew\n,\n                \nlabel\n: \nOpen New\n\n            },\n            null,\n            {\n                \nid\n: \nHelp\n\n            },\n            {\n                \nid\n: \nAbout\n,\n                \nlabel\n: \nAbout Adobe CVG Viewer...\n\n            }\n        ]\n    }\n}\n\n\n\n\nRead json file\n\n\nimport json\nfrom pprint import pprint\n\nwith open('sample_json.json') as data_file:\n    data = json.load(data_file)\n\npprint(data)\n\n\n\n\nResult\n\n\n{u'menu': {u'header': u'Sample Menu',\n           u'items': [{u'id': u'Open'},\n                      {u'id': u'OpenNew', u'label': u'Open New'},\n                      None,\n                      {u'id': u'Help'},\n                      {u'id': u'About',\n                       u'label': u'About Adobe CVG Viewer...'}]}}\n\n\n\n\nRelated Reading\n\n\n\n\nParsing values from a JSON file in Python, \nstackoverflow\n\n\nHow do I write JSON data to a file in Python?, \nstackoverflow\n\n\n\n\nXML\n\n\nWrite xml file with \nlxml\n package\n\n\nimport lxml.etree as ET\n# root declaration\nroot = ET.Element('catalog')\n# insert comment\ncomment = ET.Comment(' this is a xml sample file ')\nroot.insert(1, comment)\n# book element\nbook = ET.SubElement(root, 'book', id=\nbk001\n)\n# book data\nauthor = ET.SubElement(book, 'author')\nauthor.text = \nGambardella, Matthew\n\ntitle = ET.SubElement(book, 'title')\ntitle.text = \nXML Developer's Guide\n\n# write xml to file\ntree = ET.ElementTree(root)\ntree.write(\nsample_book.xml\n, pretty_print=True, xml_declaration=True, encoding='utf-8')\n\n\n\n\nResult\n\n\n?xml version='1.0' encoding='UTF-8'?\n\n\ncatalog\n\n  \n!-- this is a xml sample file --\n\n  \nbook id=\nbk001\n\n    \nauthor\nGambardella, Matthew\n/author\n\n    \ntitle\nXML Developer's Guide\n/title\n\n  \n/book\n\n\n/catalog\n\n\n\n\n\nRead xml file with \nlxml\n package\n\n\nfrom lxml import etree as ET\n\ntree = ET.parse(\nsample_book.xml\n)\nroot = tree.getroot()\nbook = root.find('book')\nprint \nBook Information\n\nprint \nID     :\n, book.attrib[\nid\n]\nprint \nAuthor :\n, book.find('author').text\nprint \nTitle  :\n, book.find('title').text\n\n\n\n\nResult\n\n\nBook Information\nID     : bk001\nAuthor : Gambardella, Matthew\nTitle  : XML Developer's Guide", 
            "title": "File System & IO"
        }, 
        {
            "location": "/io/#json", 
            "text": "Write json file with pretty format and unicode  import json\nimport io\n\ndata = {\n     menu : {\n         header :  Sample Menu ,\n         items : [\n            { id :  Open },\n            { id :  OpenNew ,  label :  Open New },\n            None,\n            { id :  Help },\n            { id :  About ,  label :  About Adobe CVG Viewer... }\n        ]\n    }}\n\nwith io.open( sample_json.json ,  w , encoding= utf8 ) as f:\n    content = json.dumps(data, indent=4, sort_keys=True, ensure_ascii=False)\n    f.write(unicode(content))  Result  {\n     menu : {\n         header :  Sample Menu ,\n         items : [\n            {\n                 id :  Open \n            },\n            {\n                 id :  OpenNew ,\n                 label :  Open New \n            },\n            null,\n            {\n                 id :  Help \n            },\n            {\n                 id :  About ,\n                 label :  About Adobe CVG Viewer... \n            }\n        ]\n    }\n}  Read json file  import json\nfrom pprint import pprint\n\nwith open('sample_json.json') as data_file:\n    data = json.load(data_file)\n\npprint(data)  Result  {u'menu': {u'header': u'Sample Menu',\n           u'items': [{u'id': u'Open'},\n                      {u'id': u'OpenNew', u'label': u'Open New'},\n                      None,\n                      {u'id': u'Help'},\n                      {u'id': u'About',\n                       u'label': u'About Adobe CVG Viewer...'}]}}  Related Reading   Parsing values from a JSON file in Python,  stackoverflow  How do I write JSON data to a file in Python?,  stackoverflow", 
            "title": "JSON"
        }, 
        {
            "location": "/io/#xml", 
            "text": "Write xml file with  lxml  package  import lxml.etree as ET\n# root declaration\nroot = ET.Element('catalog')\n# insert comment\ncomment = ET.Comment(' this is a xml sample file ')\nroot.insert(1, comment)\n# book element\nbook = ET.SubElement(root, 'book', id= bk001 )\n# book data\nauthor = ET.SubElement(book, 'author')\nauthor.text =  Gambardella, Matthew \ntitle = ET.SubElement(book, 'title')\ntitle.text =  XML Developer's Guide \n# write xml to file\ntree = ET.ElementTree(root)\ntree.write( sample_book.xml , pretty_print=True, xml_declaration=True, encoding='utf-8')  Result  ?xml version='1.0' encoding='UTF-8'?  catalog \n   !-- this is a xml sample file -- \n   book id= bk001 \n     author Gambardella, Matthew /author \n     title XML Developer's Guide /title \n   /book  /catalog   Read xml file with  lxml  package  from lxml import etree as ET\n\ntree = ET.parse( sample_book.xml )\nroot = tree.getroot()\nbook = root.find('book')\nprint  Book Information \nprint  ID     : , book.attrib[ id ]\nprint  Author : , book.find('author').text\nprint  Title  : , book.find('title').text  Result  Book Information\nID     : bk001\nAuthor : Gambardella, Matthew\nTitle  : XML Developer's Guide", 
            "title": "XML"
        }, 
        {
            "location": "/os/", 
            "text": "Operating System\n\n\nFile Operations\n\n\nCopy folder \n1\n\n\nimport shutil\nshutil.copyfile(\nsrc\n, \ndst\n)\n\n\n\n\nCLI\n\n\n\n\n\n\n\n\n\n\nshutil \u2014 High-level file operations", 
            "title": "Operating System"
        }, 
        {
            "location": "/os/#operating-system", 
            "text": "", 
            "title": "Operating System"
        }, 
        {
            "location": "/os/#file-operations", 
            "text": "Copy folder  1  import shutil\nshutil.copyfile( src ,  dst )", 
            "title": "File Operations"
        }, 
        {
            "location": "/os/#cli", 
            "text": "shutil \u2014 High-level file operations", 
            "title": "CLI"
        }, 
        {
            "location": "/networking/", 
            "text": "REST\n\n\nJSON \n1\n \n2\n\n\nGET\n\n\nimport requests\nurl = \nhttp://localhost:8080/messages\n\nresponse = requests.get(url)\ndata = response.json()\n\n\n\n\nPOST\n \n3\n\n\nimport requests\nimport json\n\nurl = \nhttp://localhost:8080/messages\n\ndata = {'sender': 'Alice', 'receiver': 'Bob', 'message': 'Hello!'}\nheaders = {\n  'Content-type': 'application/json',\n  'Accept': 'application/json'}\nr = requests.post(url, data=json.dumps(data), headers=headers)\n\n\n\n\n\n\n\n\n\n\n\n\nHow to get JSON from webpage into Python script\n\n\n\n\n\n\nRequests: HTTP for Humans\n\n\n\n\n\n\nPost JSON using Python Requests", 
            "title": "Networking"
        }, 
        {
            "location": "/networking/#rest", 
            "text": "", 
            "title": "REST"
        }, 
        {
            "location": "/networking/#json-1-2", 
            "text": "GET  import requests\nurl =  http://localhost:8080/messages \nresponse = requests.get(url)\ndata = response.json()  POST   3  import requests\nimport json\n\nurl =  http://localhost:8080/messages \ndata = {'sender': 'Alice', 'receiver': 'Bob', 'message': 'Hello!'}\nheaders = {\n  'Content-type': 'application/json',\n  'Accept': 'application/json'}\nr = requests.post(url, data=json.dumps(data), headers=headers)      How to get JSON from webpage into Python script    Requests: HTTP for Humans    Post JSON using Python Requests", 
            "title": "JSON 1 2"
        }, 
        {
            "location": "/concurrency_parallelism/", 
            "text": "Running several threads is similar to running several different programs concurrently, but with the following benefits\n\n\n\n\nMultiple threads within a process share the same data space with the main thread and can therefore share information or communicate with each other more easily than if they were separate processes.\n\n\nThreads sometimes called light-weight processes and they do not require much memory overhead; they are cheaper than processes.\n\n\n\n\nA thread has a beginning, an execution sequence, and a conclusion. It has an instruction pointer that keeps track of where within its context it is currently running.\n\n\n\n\nIt can be pre-empted (interrupted)\n\n\nIt can temporarily be put on hold (also known as sleeping) while other threads are running - this is called yielding.\n\n\n\n\nStarting a New Thread\n\n\nTo spawn another thread, you need to call following method available in thread module:\n\n\nthread.start_new_thread ( function, args[, kwargs] )\n\n\n\n\nThis method call enables a fast and efficient way to create new threads in both Linux and Windows.\n\n\nThe method call returns immediately and the child thread starts and calls function with the passed list of args. When function returns, the thread terminates.\n\n\nHere, args is a tuple of arguments; use an empty tuple to call function without passing any arguments. kwargs is an optional dictionary of keyword arguments.\n\n\nExample\n\n\n#!/usr/bin/python\n\nimport thread\nimport time\n\n# Define a function for the thread\ndef print_time( threadName, delay):\n   count = 0\n   while count \n 5:\n      time.sleep(delay)\n      count += 1\n      print \n%s: %s\n % ( threadName, time.ctime(time.time()) )\n\n# Create two threads as follows\ntry:\n   thread.start_new_thread( print_time, (\nThread-1\n, 2, ) )\n   thread.start_new_thread( print_time, (\nThread-2\n, 4, ) )\nexcept:\n   print \nError: unable to start thread\n\n\nwhile 1:\n   pass\n\n\n\n\nWhen the above code is executed, it produces the following result\n\n\nThread-1: Thu Jan 22 15:42:17 2009\nThread-1: Thu Jan 22 15:42:19 2009\nThread-2: Thu Jan 22 15:42:19 2009\nThread-1: Thu Jan 22 15:42:21 2009\nThread-2: Thu Jan 22 15:42:23 2009\nThread-1: Thu Jan 22 15:42:23 2009\nThread-1: Thu Jan 22 15:42:25 2009\nThread-2: Thu Jan 22 15:42:27 2009\nThread-2: Thu Jan 22 15:42:31 2009\nThread-2: Thu Jan 22 15:42:35 2009\n\n\n\n\nAlthough it is very effective for low-level threading, but the thread module is very limited compared to the newer threading module.\n\n\nThe Threading Module\n\n\nThe newer threading module included with Python 2.4 provides much more powerful, high-level support for threads than the thread module discussed in the previous section.\n\n\nThe threading module exposes all the methods of the thread module and provides some additional methods:\n\n\n\n\nthreading.activeCount()\n: Returns the number of thread objects that are active.\n\n\nthreading.currentThread()\n: Returns the number of thread objects in the caller's thread control.\n\n\nthreading.enumerate()\n: Returns a list of all thread objects that are currently active.\n\n\n\n\nIn addition to the methods, the threading module has the Thread class that implements threading. The methods provided by the Thread class are as follows:\n\n\n\n\nrun()\n: The run() method is the entry point for a thread.\n\n\nstart()\n: The start() method starts a thread by calling the run method.\n\n\njoin([time])\n: The join() waits for threads to terminate.\n\n\nisAlive(): The isAlive() method checks whether a thread is still executing.\n\n\ngetName()\n: The getName() method returns the name of a thread.\n\n\nsetName()\n: The setName() method sets the name of a thread.\n\n\n\n\nCreating Thread Using Threading Module\n\n\nTo implement a new thread using the threading module, you have to do the following \u2212\n\n\n\n\nDefine a new subclass of the Thread class.\n\n\nOverride the \ninit\n(self [,args]) method to add additional arguments.\n\n\nThen, override the run(self [,args]) method to implement what the thread should do when started.\n\n\n\n\nOnce you have created the new Thread subclass, you can create an instance of it and then start a new thread by invoking the start(), which in turn calls run() method.\n\n\nExample\n\n\n#!/usr/bin/python\n\nimport threading\nimport time\n\nexitFlag = 0\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, counter):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.counter = counter\n    def run(self):\n        print \nStarting \n + self.name\n        print_time(self.name, self.counter, 5)\n        print \nExiting \n + self.name\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        if exitFlag:\n            threadName.exit()\n        time.sleep(delay)\n        print \n%s: %s\n % (threadName, time.ctime(time.time()))\n        counter -= 1\n\n# Create new threads\nthread1 = myThread(1, \nThread-1\n, 1)\nthread2 = myThread(2, \nThread-2\n, 2)\n\n# Start new Threads\nthread1.start()\nthread2.start()\n\nprint \nExiting Main Thread\n\n\n\n\n\nWhen the above code is executed, it produces the following result\n\n\nStarting Thread-1\nStarting Thread-2\nExiting Main Thread\nThread-1: Thu Mar 21 09:10:03 2013\nThread-1: Thu Mar 21 09:10:04 2013\nThread-2: Thu Mar 21 09:10:04 2013\nThread-1: Thu Mar 21 09:10:05 2013\nThread-1: Thu Mar 21 09:10:06 2013\nThread-2: Thu Mar 21 09:10:06 2013\nThread-1: Thu Mar 21 09:10:07 2013\nExiting Thread-1\nThread-2: Thu Mar 21 09:10:08 2013\nThread-2: Thu Mar 21 09:10:10 2013\nThread-2: Thu Mar 21 09:10:12 2013\nExiting Thread-2\n\n\n\n\nSynchronizing Threads\n\n\nThe threading module provided with Python includes a simple-to-implement locking mechanism that allows you to synchronize threads. A new lock is created by calling the Lock() method, which returns the new lock.\n\n\nThe acquire(blocking) method of the new lock object is used to force threads to run synchronously. The optional blocking parameter enables you to control whether the thread waits to acquire the lock.\n\n\nIf blocking is set to 0, the thread returns immediately with a 0 value if the lock cannot be acquired and with a 1 if the lock was acquired. If blocking is set to 1, the thread blocks and wait for the lock to be released.\n\n\nThe release() method of the new lock object is used to release the lock when it is no longer required.\n\n\nExample\n\n\n#!/usr/bin/python\n\nimport threading\nimport time\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, counter):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.counter = counter\n    def run(self):\n        print \nStarting \n + self.name\n        # Get lock to synchronize threads\n        threadLock.acquire()\n        print_time(self.name, self.counter, 3)\n        # Free lock to release next thread\n        threadLock.release()\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        time.sleep(delay)\n        print \n%s: %s\n % (threadName, time.ctime(time.time()))\n        counter -= 1\n\nthreadLock = threading.Lock()\nthreads = []\n\n# Create new threads\nthread1 = myThread(1, \nThread-1\n, 1)\nthread2 = myThread(2, \nThread-2\n, 2)\n\n# Start new Threads\nthread1.start()\nthread2.start()\n\n# Add threads to thread list\nthreads.append(thread1)\nthreads.append(thread2)\n\n# Wait for all threads to complete\nfor t in threads:\n    t.join()\nprint \nExiting Main Thread\n\n\n\n\n\nWhen the above code is executed, it produces the following result\n\n\nStarting Thread-1\nStarting Thread-2\nStarting Thread-3\nThread-1 processing One\nThread-2 processing Two\nThread-3 processing Three\nThread-1 processing Four\nThread-2 processing Five\nExiting Thread-3\nExiting Thread-1\nExiting Thread-2\nExiting Main Thread\n\n\n\n\nRelated Readings\n\n\n\n\n\"Python Multithreaded Programming\". \nwww.tutorialspoint.com\n. N.p., 2016. Web. 13 Dec. 2016.\n\n\n\"An Introduction To Python Concurrency\". \ndabeaz.com\n. N.p., 2016. Web. 14 Dec. 2016.", 
            "title": "Concurrency and Parallelism"
        }, 
        {
            "location": "/concurrency_parallelism/#starting-a-new-thread", 
            "text": "To spawn another thread, you need to call following method available in thread module:  thread.start_new_thread ( function, args[, kwargs] )  This method call enables a fast and efficient way to create new threads in both Linux and Windows.  The method call returns immediately and the child thread starts and calls function with the passed list of args. When function returns, the thread terminates.  Here, args is a tuple of arguments; use an empty tuple to call function without passing any arguments. kwargs is an optional dictionary of keyword arguments.  Example  #!/usr/bin/python\n\nimport thread\nimport time\n\n# Define a function for the thread\ndef print_time( threadName, delay):\n   count = 0\n   while count   5:\n      time.sleep(delay)\n      count += 1\n      print  %s: %s  % ( threadName, time.ctime(time.time()) )\n\n# Create two threads as follows\ntry:\n   thread.start_new_thread( print_time, ( Thread-1 , 2, ) )\n   thread.start_new_thread( print_time, ( Thread-2 , 4, ) )\nexcept:\n   print  Error: unable to start thread \n\nwhile 1:\n   pass  When the above code is executed, it produces the following result  Thread-1: Thu Jan 22 15:42:17 2009\nThread-1: Thu Jan 22 15:42:19 2009\nThread-2: Thu Jan 22 15:42:19 2009\nThread-1: Thu Jan 22 15:42:21 2009\nThread-2: Thu Jan 22 15:42:23 2009\nThread-1: Thu Jan 22 15:42:23 2009\nThread-1: Thu Jan 22 15:42:25 2009\nThread-2: Thu Jan 22 15:42:27 2009\nThread-2: Thu Jan 22 15:42:31 2009\nThread-2: Thu Jan 22 15:42:35 2009  Although it is very effective for low-level threading, but the thread module is very limited compared to the newer threading module.", 
            "title": "Starting a New Thread"
        }, 
        {
            "location": "/concurrency_parallelism/#the-threading-module", 
            "text": "The newer threading module included with Python 2.4 provides much more powerful, high-level support for threads than the thread module discussed in the previous section.  The threading module exposes all the methods of the thread module and provides some additional methods:   threading.activeCount() : Returns the number of thread objects that are active.  threading.currentThread() : Returns the number of thread objects in the caller's thread control.  threading.enumerate() : Returns a list of all thread objects that are currently active.   In addition to the methods, the threading module has the Thread class that implements threading. The methods provided by the Thread class are as follows:   run() : The run() method is the entry point for a thread.  start() : The start() method starts a thread by calling the run method.  join([time]) : The join() waits for threads to terminate.  isAlive(): The isAlive() method checks whether a thread is still executing.  getName() : The getName() method returns the name of a thread.  setName() : The setName() method sets the name of a thread.", 
            "title": "The Threading Module"
        }, 
        {
            "location": "/concurrency_parallelism/#creating-thread-using-threading-module", 
            "text": "To implement a new thread using the threading module, you have to do the following \u2212   Define a new subclass of the Thread class.  Override the  init (self [,args]) method to add additional arguments.  Then, override the run(self [,args]) method to implement what the thread should do when started.   Once you have created the new Thread subclass, you can create an instance of it and then start a new thread by invoking the start(), which in turn calls run() method.  Example  #!/usr/bin/python\n\nimport threading\nimport time\n\nexitFlag = 0\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, counter):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.counter = counter\n    def run(self):\n        print  Starting   + self.name\n        print_time(self.name, self.counter, 5)\n        print  Exiting   + self.name\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        if exitFlag:\n            threadName.exit()\n        time.sleep(delay)\n        print  %s: %s  % (threadName, time.ctime(time.time()))\n        counter -= 1\n\n# Create new threads\nthread1 = myThread(1,  Thread-1 , 1)\nthread2 = myThread(2,  Thread-2 , 2)\n\n# Start new Threads\nthread1.start()\nthread2.start()\n\nprint  Exiting Main Thread   When the above code is executed, it produces the following result  Starting Thread-1\nStarting Thread-2\nExiting Main Thread\nThread-1: Thu Mar 21 09:10:03 2013\nThread-1: Thu Mar 21 09:10:04 2013\nThread-2: Thu Mar 21 09:10:04 2013\nThread-1: Thu Mar 21 09:10:05 2013\nThread-1: Thu Mar 21 09:10:06 2013\nThread-2: Thu Mar 21 09:10:06 2013\nThread-1: Thu Mar 21 09:10:07 2013\nExiting Thread-1\nThread-2: Thu Mar 21 09:10:08 2013\nThread-2: Thu Mar 21 09:10:10 2013\nThread-2: Thu Mar 21 09:10:12 2013\nExiting Thread-2", 
            "title": "Creating Thread Using Threading Module"
        }, 
        {
            "location": "/concurrency_parallelism/#synchronizing-threads", 
            "text": "The threading module provided with Python includes a simple-to-implement locking mechanism that allows you to synchronize threads. A new lock is created by calling the Lock() method, which returns the new lock.  The acquire(blocking) method of the new lock object is used to force threads to run synchronously. The optional blocking parameter enables you to control whether the thread waits to acquire the lock.  If blocking is set to 0, the thread returns immediately with a 0 value if the lock cannot be acquired and with a 1 if the lock was acquired. If blocking is set to 1, the thread blocks and wait for the lock to be released.  The release() method of the new lock object is used to release the lock when it is no longer required.  Example  #!/usr/bin/python\n\nimport threading\nimport time\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, counter):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.counter = counter\n    def run(self):\n        print  Starting   + self.name\n        # Get lock to synchronize threads\n        threadLock.acquire()\n        print_time(self.name, self.counter, 3)\n        # Free lock to release next thread\n        threadLock.release()\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        time.sleep(delay)\n        print  %s: %s  % (threadName, time.ctime(time.time()))\n        counter -= 1\n\nthreadLock = threading.Lock()\nthreads = []\n\n# Create new threads\nthread1 = myThread(1,  Thread-1 , 1)\nthread2 = myThread(2,  Thread-2 , 2)\n\n# Start new Threads\nthread1.start()\nthread2.start()\n\n# Add threads to thread list\nthreads.append(thread1)\nthreads.append(thread2)\n\n# Wait for all threads to complete\nfor t in threads:\n    t.join()\nprint  Exiting Main Thread   When the above code is executed, it produces the following result  Starting Thread-1\nStarting Thread-2\nStarting Thread-3\nThread-1 processing One\nThread-2 processing Two\nThread-3 processing Three\nThread-1 processing Four\nThread-2 processing Five\nExiting Thread-3\nExiting Thread-1\nExiting Thread-2\nExiting Main Thread", 
            "title": "Synchronizing Threads"
        }, 
        {
            "location": "/concurrency_parallelism/#related-readings", 
            "text": "\"Python Multithreaded Programming\".  www.tutorialspoint.com . N.p., 2016. Web. 13 Dec. 2016.  \"An Introduction To Python Concurrency\".  dabeaz.com . N.p., 2016. Web. 14 Dec. 2016.", 
            "title": "Related Readings"
        }, 
        {
            "location": "/event_based/", 
            "text": "Introduction: \npydispatcher\n \n1\n \n2\n\n\nPyDispatcher provides the Python programmer with a \nmultiple-producer-multiple-consumer signal-registration\n and \nrouting infrastructure\n for use in multiple contexts.  The mechanism of PyDispatcher started life as a highly rated recipe in the Python Cookbook.  The project aims to include various enhancements to the recipe developed during use in various applications.  It is primarily maintained by Mike Fletcher.  A derivative of the project provides the Django web framework's \"signal\" system.\n\n\nUsed by Django community\n\n\nUsage \n1\n\n\n# To set up a function to receive signals:\nfrom pydispatch import dispatcher\n\nSIGNAL = 'my-first-signal'\n\n\ndef handle_event(sender):\n    \nSimple event handler\n\n    print 'Signal was sent by', sender\n\n\ndispatcher.connect(handle_event, signal=SIGNAL, sender=dispatcher.Any)\n\n# The use of the Any object allows the handler to listen for messages\n# from any Sender or to listen to Any message being sent.\n# To send messages:\nfirst_sender = object()\nsecond_sender = {}\n\n\ndef main():\n    dispatcher.send(signal=SIGNAL, sender=first_sender)\n    dispatcher.send(signal=SIGNAL, sender=second_sender)\n\n    # Which causes the following to be printed:\n\n    # Signal was sent by \nobject object at 0x196a090\n\n    # Signal was sent by {}\n\n\n\n\nMessaging\n\n\nConda link\n\n\nDocker link\n\n\nGithub - pubSubService\n\n\nGithub - pubSubClient\n\n\nPypi link\n\n\nPython Publish - Subscribe Pattern Implementation:\n\n\nStep by Step to run PubSub:\n\n\nStep 1: Pull \npubsub\n image from docker hub \n run it:\n\n\ndocker pull hunguyen/pubsub:latest\ndocker run -d -p 8000:8000 hunguyen/pubsub\n\n\n\n\nStep 2: To run client first install \npyconfiguration\n from conda\n\n\nconda install -c rain1024 pyconfiguration\n\n\n\n\nStep 3: Install \npubSubClient\n package from conda\n\n\nconda install -c hunguyen pubsubclient\n\n\n\n\nStep 4: Create \nconfig.json\n file\n\n\n{\n  \nPUBLISH_SUBSCRIBE_SERVICE\n: \nhttp://api.service.com\n\n}\n\n\n\n\nStep 5: Run \npubsubclient\n\n\n# create and register or sync a publisher\npublisher = Publisher('P1')\n# create a new topic\ntopic = Topic('A')\n# create an event of a topic\nevent = Event(topic)\n# publisher publishes an event\npublisher.publish(event)\n# create and register or sync a subscriber\nsubscriber = Subscriber('S1')\n# subscriber subscribes to a topic\nsubscriber.subscribe(topic)\n# subscriber get all new events by time stamp of topics which it has subscribed\nevents = subscriber.get_events()\n\n\n\n\n\n\n\n\n\n\n\n\npydispatcher\n\n\n\n\n\n\nstackoverflow, Recommended Python publish/subscribe/dispatch module?", 
            "title": "Event Based"
        }, 
        {
            "location": "/event_based/#introduction-pydispatcher-1-2", 
            "text": "PyDispatcher provides the Python programmer with a  multiple-producer-multiple-consumer signal-registration  and  routing infrastructure  for use in multiple contexts.  The mechanism of PyDispatcher started life as a highly rated recipe in the Python Cookbook.  The project aims to include various enhancements to the recipe developed during use in various applications.  It is primarily maintained by Mike Fletcher.  A derivative of the project provides the Django web framework's \"signal\" system.  Used by Django community", 
            "title": "Introduction: pydispatcher 1 2"
        }, 
        {
            "location": "/event_based/#usage-1", 
            "text": "# To set up a function to receive signals:\nfrom pydispatch import dispatcher\n\nSIGNAL = 'my-first-signal'\n\n\ndef handle_event(sender):\n     Simple event handler \n    print 'Signal was sent by', sender\n\n\ndispatcher.connect(handle_event, signal=SIGNAL, sender=dispatcher.Any)\n\n# The use of the Any object allows the handler to listen for messages\n# from any Sender or to listen to Any message being sent.\n# To send messages:\nfirst_sender = object()\nsecond_sender = {}\n\n\ndef main():\n    dispatcher.send(signal=SIGNAL, sender=first_sender)\n    dispatcher.send(signal=SIGNAL, sender=second_sender)\n\n    # Which causes the following to be printed:\n\n    # Signal was sent by  object object at 0x196a090 \n    # Signal was sent by {}", 
            "title": "Usage 1"
        }, 
        {
            "location": "/event_based/#messaging", 
            "text": "Conda link  Docker link  Github - pubSubService  Github - pubSubClient  Pypi link  Python Publish - Subscribe Pattern Implementation:", 
            "title": "Messaging"
        }, 
        {
            "location": "/event_based/#step-by-step-to-run-pubsub", 
            "text": "", 
            "title": "Step by Step to run PubSub:"
        }, 
        {
            "location": "/event_based/#step-1-pull-pubsub-image-from-docker-hub-run-it", 
            "text": "docker pull hunguyen/pubsub:latest\ndocker run -d -p 8000:8000 hunguyen/pubsub", 
            "title": "Step 1: Pull pubsub image from docker hub &amp; run it:"
        }, 
        {
            "location": "/event_based/#step-2-to-run-client-first-install-pyconfiguration-from-conda", 
            "text": "conda install -c rain1024 pyconfiguration", 
            "title": "Step 2: To run client first install pyconfiguration from conda"
        }, 
        {
            "location": "/event_based/#step-3-install-pubsubclient-package-from-conda", 
            "text": "conda install -c hunguyen pubsubclient", 
            "title": "Step 3: Install pubSubClient package from conda"
        }, 
        {
            "location": "/event_based/#step-4-create-configjson-file", 
            "text": "{\n   PUBLISH_SUBSCRIBE_SERVICE :  http://api.service.com \n}", 
            "title": "Step 4: Create config.json file"
        }, 
        {
            "location": "/event_based/#step-5-run-pubsubclient", 
            "text": "# create and register or sync a publisher\npublisher = Publisher('P1')\n# create a new topic\ntopic = Topic('A')\n# create an event of a topic\nevent = Event(topic)\n# publisher publishes an event\npublisher.publish(event)\n# create and register or sync a subscriber\nsubscriber = Subscriber('S1')\n# subscriber subscribes to a topic\nsubscriber.subscribe(topic)\n# subscriber get all new events by time stamp of topics which it has subscribed\nevents = subscriber.get_events()      pydispatcher    stackoverflow, Recommended Python publish/subscribe/dispatch module?", 
            "title": "Step 5: Run pubsubclient"
        }, 
        {
            "location": "/web/", 
            "text": "Django \n1\n\n\nDjango is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source.\n\n\nProject Folder Structure\n\n\nproject_folder/\n\u251c\u2500\u2500 your_project_name/\n\u2502   \u251c\u2500\u2500 your_project_name/\n\u2502   \u2502   \u251c\u2500\u2500 static/\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 serializers.py\n\u2502   \u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2502   \u2514\u2500\u2500 views.py\n\u2514   \u2514\u2500\u2500 manage.py\n\n\n\n\nCreate (and use) REST API in 5 (+1) steps \n1\n \n2\n\n\nStep 1: Install dependencies\n\n\npip install django\npip install djangorestframework\npip install markdown             # Markdown support for the browsable API.\npip install django-filter        # Filtering support\npip install django-cors-headers  # CORS support\n\n\n\n\nStep 2: Create project\n\n\ndjango-admin startproject your_project_name\n\n\n\n\nStep 3: Config apps \n3\n\n\nAdd 'your_project_name', 'rest_framework' to your INSTALLED_APPS setting in \nyour_project_name/settings.py\n file\n\n\nINSTALLED_APPS = (\n    ...\n    'your_project_name'\n    'rest_framework',\n)\n\n\n\n\nStep 4: \nModel\n, \nView\n, \nRoute\n \n6\n\n\nStep 4.1: Create model and serializer\n\n\nYou can go to \nDjango: Model field reference page\n for more fields.\n\n\nStep 4.1.1: Create \nTask\n class in \nyour_project_name/models.py\n file\n\n\nfrom django.db import models\n\nclass Task(models.Model):\n    content = models.CharField(max_length=30)\n    status = models.CharField(max_length=30)\n\n\n\n\nStep 4.1.2: Create \nTaskSerializer\n class in \nyour_project_name/serializers.py\n file\n\n\nfrom your_project_name.models import Task\nfrom rest_framework import serializers\n\nclass TaskSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = Task\n        fields = ('id', 'content', 'status')\n\n\n\n\nStep 4.1.3: Create table in database \n4\n\n\npython manage.py syncdb\n\n\n\n\nWith \ndjango 1.9\n\n\npython manage.py makemigrations your_project_name\npython manage.py migrate\n\n\n\n\nStep 4.2: Create \nTaskViewSet\n class in \nyour_project_name/views.py\n file\n\n\nfrom your_project_name.models import Task\nfrom your_project_name.serializers import TaskSerializer\nfrom rest_framework import viewsets\n\nclass TaskViewSet(viewsets.ModelViewSet):\n    queryset = Task.objects.all()\n    serializer_class = TaskSerializer\n\n\n\n\nStep 4.3: Config \nroute\n \n5\n\n\nChange \nyour_project_name/urls.py\n file\n\n\nfrom django.conf.urls import include, url\nfrom django.contrib import admin\nfrom rest_framework import routers\nfrom your_project_name.views import TaskViewSet\n\nrouter = routers.DefaultRouter()\nrouter.register(r'api/tasks', TaskViewSet)\nadmin.autodiscover()\n\nurlpatterns = [\n    url(r'^admin/', include(admin.site.urls)),\n    url(r'^', include(router.urls)),\n    url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))\n]\n\n\n\n\nStep 5: Run Server\n\n\npython manage.py runserver\n\n\n\n\nStep 6. Use API\n\n\nStep 6.1: Create a new task\n\n\ncurl -i -X POST -H \nContent-Type:application/json\n http://localhost:8000/api/tasks -d '{\n  \ncontent\n: \na\n,\n  \nstatus\n: \nINIT\n\n}'\n\n\n\n\nStep 6.2: List all tasks\n\n\ncurl http://localhost:8000/api/tasks\n\n\n\n\nStep 6.3: Get detail of task 1\n\n\ncurl http://localhost:8000/api/tasks/1\n\n\n\n\nStep 6.4: Delete task 1\n\n\ncurl -i -X DELETE http://localhost:8000/api/tasks/1\n\n\n\n\nStep 7: CORS\n\n\nKnown Error: \nNo 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access.\n\n\nStep 7.1: Install \ncorsheader\n app\n\n\nAdd module \ncorsheaders\n to \nyour_project_name/settings.py\n\n\nINSTALLED_APPS = (\n    ...\n    'corsheaders',\n    ...\n)\n\n\n\n\nStep 7.2 Add middleware classes\n\n\nAdd middleware_classes to \nyour_project_name/settings.py\n\n\nMIDDLEWARE_CLASSES = (\n    ...\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    ...\n)\n\n\n\n\nStep 7.3 Configuration CORS Setting\n\n\nOption 1\n: Allow All\n\n\nAdd this line to \nyour_project_name/settings.py\n\n\nCORS_ORIGIN_ALLOW_ALL: True\n\n\n\n\nStep 8: https\n\n\nYou can use \nhttps://github.com/teddziuba/django-sslserver\n\n\nUnicode\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': (\n        'rest_framework.renderers.JSONRenderer',\n        'rest_framework.renderers.BrowsableAPIRenderer',\n    )\n}\n\n\n\n\nStep 9: Paging\n\n\nAdd this module setting to \nyour_project_name/settings.py\n\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',\n}\n\n\n\n\n\nAPI:\n\n\n\nGET \n/?limit=\nlimit\noffset=\noffset\n\n\n\n\n\n\nStep 10: Search by field in\n\n\nimport this to your \nviewsets.py\n\n\n\nfrom rest_framework import filters\n\n\n\n\n\nadd this to your viewsets class\n\n\n\nfilter_backends = (filters.SearchFilter, )\nsearch_fields = ('\nfield\n','\nfield\n',)\n\n\n\n\n\nOne-to-Many Relationship \n7\n\n\nfrom django.db import models\n\nclass User(models.Model):\n    name = models.TextField()\n\n    def __str__(self):\n        return \n{} - {}\n.format(str(self.id), self.name)\n\n\nclass Task(models.Model):\n    name = models.TextField()\n    assign = models.ForeignKey(User, on_delete=models.CASCADE)\n\n\n\n\nStarting with Mysql\n\n\nAdd this database settings to \nyour_project_name/settings.py\n\n\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': '[DB_NAME]',\n        'USER': '[DB_USER]',\n        'PASSWORD': '[PASSWORD]',\n        'HOST': '[HOST]',   # Or an IP Address that your DB is hosted on\n        'PORT': '3306',\n    }\n}\n\n\n\n\n\nInstall this module to your virtual environment\n\n\n\nconda install mysql-python #if you are using virtual environment\n\npip install mysql-python #if you using are root environment\n\n\n\n\n\nCustom View \n8\n\n\nfrom rest_framework import mixins\n\n\nclass CreateModelMixin(object):\n    \n\n    Create a model instance.\n    \n\n    def create(self, request, *args, **kwargs):\n        event = request.data\n        try:\n            event['time'] = int(time.time())\n        except Exception, e:\n            print 'Set Time Error'\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n    def get_success_headers(self, data):\n        try:\n            return {'Location': data[api_settings.URL_FIELD_NAME]}\n        except (TypeError, KeyError):\n            return {}\n\nclass YourViewSet(CreateModelMixin,\n                  mixins.RetrieveModelMixin,\n                  mixins.UpdateModelMixin,\n                  mixins.DestroyModelMixin,\n                  mixins.ListModelMixin,\n                  GenericViewSet):\n    queryset = YourModel.objects.all()\n    serializer_class = YourModelSerializer\n\n\n\n\nLogging settings\n\n\nHere is an example, put this settings dict into your \nsettings.py\n file:\n\n\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'verbose': {\n            'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'\n        },\n        'simple': {\n            'format': '%(levelname)s %(message)s'\n        },\n    },\n    'filters': {\n        'special': {\n            '()': 'project.logging.SpecialFilter',\n            'foo': 'bar',\n        },\n        'require_debug_true': {\n            '()': 'django.utils.log.RequireDebugTrue',\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': 'INFO',\n            'filters': ['require_debug_true'],\n            'class': 'logging.StreamHandler',\n            'formatter': 'simple'\n        },\n        'mail_admins': {\n            'level': 'ERROR',\n            'class': 'django.utils.log.AdminEmailHandler',\n            'filters': ['special']\n        }\n    },\n    'loggers': {\n        'django': {\n            'handlers': ['console'],\n            'propagate': True,\n        },\n        'django.request': {\n            'handlers': ['mail_admins'],\n            'level': 'ERROR',\n            'propagate': False,\n        },\n        'myproject.custom': {\n            'handlers': ['console', 'mail_admins'],\n            'level': 'INFO',\n            'filters': ['special']\n        }\n    }\n}\n\n\n\n\n\nPython: Build Python API Client package\n\n\nStep 1: Write document on \nSwagger Editor\n1\n\n\nStep 2: Genenrate Client --\n Python --\n save \npython-client.zip\n\n\nStep 3: Extract \nzip\n\n\nStep 4: Open project in \nPycharm\n rename \nproject directory\n, \nproject name\n, \nswagger_client\n package\n\n\nStep 5: \n2\n\n\nmkdir conda\ncd conda\ngit clone https://github.com/hunguyen1702/condaBuildLocalTemplate.git\nmv condaBuildLocalTemplate your_package_name\nrm -rf .git README.md\n\n\n\n\nStep 6: Edit \nmeta.yaml\n file in \nyour_package\n folder\n\n\n6.1 Follow instruction inside \nmeta.yaml\n\n\n6.2 Replace these line\n\n\nrequirements:\n  build:\n    - python\n    - setuptools\n  run:\n    - python\n\n\n\n\nwith:\n\n\nrequirements:\n  build:\n    - python\n    - setuptools\n    - six\n    - certifi\n    - python-dateutil\n  run:\n    - python\n    - six\n    - certifi\n    - python-dateutil\n\n\n\n\nStep 7:\n\n\ncd ..\nconda build your_package\n\n\n\n\nStep 8:\n\n\nmkdir channel\ncd channel\nconda convert --platform all ~/anaconda/conda-bld/linux-64/your_package_0.1.0-py27_0.tar.bz2\n\n\n\n\nStep 9: Create \nvirtual-env\n\n\nname: your_env_name\ndependencies:\n- certifi=2016.2.28=py27_0\n- openssl=1.0.2h=0\n- pip=8.1.2=py27_0\n- python=2.7.11=0\n- python-dateutil=2.5.3=py27_0\n- readline=6.2=2\n- setuptools=20.7.0=py27_0\n- six=1.10.0=py27_0\n- tk=8.5.18=0\n- wheel=0.29.0=py27_0\n- zlib=1.2.8=0\n- pip:\n  - urllib3==1.15.1\n\n\n\n\nStep 10: Install:\n\n\nconda install --use-local your_package\n\n\n\n\n\n\n\n\n\n\n\n\nDjango\n\n\n\n\n\n\nWriting your first Django app, part 1\n\n\n\n\n\n\nDjango REST framework: Installation\n\n\n\n\n\n\nDjango: Migrations\n\n\n\n\n\n\nBuilding a Simple REST API for Mobile Applications\n\n\n\n\n\n\nDjango: Models\n\n\n\n\n\n\nHow to show object details in Django Rest Framework browseable API?\n\n\n\n\n\n\nrest_framework:mixins", 
            "title": "Web Development"
        }, 
        {
            "location": "/web/#django-1", 
            "text": "Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source.  Project Folder Structure  project_folder/\n\u251c\u2500\u2500 your_project_name/\n\u2502   \u251c\u2500\u2500 your_project_name/\n\u2502   \u2502   \u251c\u2500\u2500 static/\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 serializers.py\n\u2502   \u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2502   \u2514\u2500\u2500 views.py\n\u2514   \u2514\u2500\u2500 manage.py", 
            "title": "Django 1"
        }, 
        {
            "location": "/web/#create-and-use-rest-api-in-5-1-steps-1-2", 
            "text": "", 
            "title": "Create (and use) REST API in 5 (+1) steps 1 2"
        }, 
        {
            "location": "/web/#step-1-install-dependencies", 
            "text": "pip install django\npip install djangorestframework\npip install markdown             # Markdown support for the browsable API.\npip install django-filter        # Filtering support\npip install django-cors-headers  # CORS support", 
            "title": "Step 1: Install dependencies"
        }, 
        {
            "location": "/web/#step-2-create-project", 
            "text": "django-admin startproject your_project_name", 
            "title": "Step 2: Create project"
        }, 
        {
            "location": "/web/#step-3-config-apps-3", 
            "text": "Add 'your_project_name', 'rest_framework' to your INSTALLED_APPS setting in  your_project_name/settings.py  file  INSTALLED_APPS = (\n    ...\n    'your_project_name'\n    'rest_framework',\n)", 
            "title": "Step 3: Config apps 3"
        }, 
        {
            "location": "/web/#step-4-model-view-route-6", 
            "text": "", 
            "title": "Step 4: Model, View, Route 6"
        }, 
        {
            "location": "/web/#step-41-create-model-and-serializer", 
            "text": "You can go to  Django: Model field reference page  for more fields.", 
            "title": "Step 4.1: Create model and serializer"
        }, 
        {
            "location": "/web/#step-411-create-task-class-in-your_project_namemodelspy-file", 
            "text": "from django.db import models\n\nclass Task(models.Model):\n    content = models.CharField(max_length=30)\n    status = models.CharField(max_length=30)", 
            "title": "Step 4.1.1: Create Task class in your_project_name/models.py file"
        }, 
        {
            "location": "/web/#step-412-create-taskserializer-class-in-your_project_nameserializerspy-file", 
            "text": "from your_project_name.models import Task\nfrom rest_framework import serializers\n\nclass TaskSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = Task\n        fields = ('id', 'content', 'status')", 
            "title": "Step 4.1.2: Create TaskSerializer class in your_project_name/serializers.py file"
        }, 
        {
            "location": "/web/#step-413-create-table-in-database-4", 
            "text": "python manage.py syncdb  With  django 1.9  python manage.py makemigrations your_project_name\npython manage.py migrate", 
            "title": "Step 4.1.3: Create table in database 4"
        }, 
        {
            "location": "/web/#step-42-create-taskviewset-class-in-your_project_nameviewspy-file", 
            "text": "from your_project_name.models import Task\nfrom your_project_name.serializers import TaskSerializer\nfrom rest_framework import viewsets\n\nclass TaskViewSet(viewsets.ModelViewSet):\n    queryset = Task.objects.all()\n    serializer_class = TaskSerializer", 
            "title": "Step 4.2: Create TaskViewSet class in your_project_name/views.py file"
        }, 
        {
            "location": "/web/#step-43-config-route-5", 
            "text": "Change  your_project_name/urls.py  file  from django.conf.urls import include, url\nfrom django.contrib import admin\nfrom rest_framework import routers\nfrom your_project_name.views import TaskViewSet\n\nrouter = routers.DefaultRouter()\nrouter.register(r'api/tasks', TaskViewSet)\nadmin.autodiscover()\n\nurlpatterns = [\n    url(r'^admin/', include(admin.site.urls)),\n    url(r'^', include(router.urls)),\n    url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))\n]", 
            "title": "Step 4.3: Config route 5"
        }, 
        {
            "location": "/web/#step-5-run-server", 
            "text": "python manage.py runserver", 
            "title": "Step 5: Run Server"
        }, 
        {
            "location": "/web/#step-6-use-api", 
            "text": "", 
            "title": "Step 6. Use API"
        }, 
        {
            "location": "/web/#step-61-create-a-new-task", 
            "text": "curl -i -X POST -H  Content-Type:application/json  http://localhost:8000/api/tasks -d '{\n   content :  a ,\n   status :  INIT \n}'", 
            "title": "Step 6.1: Create a new task"
        }, 
        {
            "location": "/web/#step-62-list-all-tasks", 
            "text": "curl http://localhost:8000/api/tasks", 
            "title": "Step 6.2: List all tasks"
        }, 
        {
            "location": "/web/#step-63-get-detail-of-task-1", 
            "text": "curl http://localhost:8000/api/tasks/1", 
            "title": "Step 6.3: Get detail of task 1"
        }, 
        {
            "location": "/web/#step-64-delete-task-1", 
            "text": "curl -i -X DELETE http://localhost:8000/api/tasks/1", 
            "title": "Step 6.4: Delete task 1"
        }, 
        {
            "location": "/web/#step-7-cors", 
            "text": "Known Error:  No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access.", 
            "title": "Step 7: CORS"
        }, 
        {
            "location": "/web/#step-71-install-corsheader-app", 
            "text": "Add module  corsheaders  to  your_project_name/settings.py  INSTALLED_APPS = (\n    ...\n    'corsheaders',\n    ...\n)", 
            "title": "Step 7.1: Install corsheader app"
        }, 
        {
            "location": "/web/#step-72-add-middleware-classes", 
            "text": "Add middleware_classes to  your_project_name/settings.py  MIDDLEWARE_CLASSES = (\n    ...\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    ...\n)", 
            "title": "Step 7.2 Add middleware classes"
        }, 
        {
            "location": "/web/#step-73-configuration-cors-setting", 
            "text": "Option 1 : Allow All  Add this line to  your_project_name/settings.py  CORS_ORIGIN_ALLOW_ALL: True", 
            "title": "Step 7.3 Configuration CORS Setting"
        }, 
        {
            "location": "/web/#step-8-https", 
            "text": "You can use  https://github.com/teddziuba/django-sslserver", 
            "title": "Step 8: https"
        }, 
        {
            "location": "/web/#unicode", 
            "text": "REST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': (\n        'rest_framework.renderers.JSONRenderer',\n        'rest_framework.renderers.BrowsableAPIRenderer',\n    )\n}", 
            "title": "Unicode"
        }, 
        {
            "location": "/web/#step-9-paging", 
            "text": "Add this module setting to  your_project_name/settings.py  \nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',\n}  API:  \nGET  /?limit= limit offset= offset", 
            "title": "Step 9: Paging"
        }, 
        {
            "location": "/web/#step-10-search-by-field-in", 
            "text": "import this to your  viewsets.py  \nfrom rest_framework import filters  add this to your viewsets class  \nfilter_backends = (filters.SearchFilter, )\nsearch_fields = (' field ',' field ',)", 
            "title": "Step 10: Search by field in"
        }, 
        {
            "location": "/web/#one-to-many-relationship-7", 
            "text": "from django.db import models\n\nclass User(models.Model):\n    name = models.TextField()\n\n    def __str__(self):\n        return  {} - {} .format(str(self.id), self.name)\n\n\nclass Task(models.Model):\n    name = models.TextField()\n    assign = models.ForeignKey(User, on_delete=models.CASCADE)", 
            "title": "One-to-Many Relationship 7"
        }, 
        {
            "location": "/web/#starting-with-mysql", 
            "text": "Add this database settings to  your_project_name/settings.py  \nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': '[DB_NAME]',\n        'USER': '[DB_USER]',\n        'PASSWORD': '[PASSWORD]',\n        'HOST': '[HOST]',   # Or an IP Address that your DB is hosted on\n        'PORT': '3306',\n    }\n}  Install this module to your virtual environment  \nconda install mysql-python #if you are using virtual environment\n\npip install mysql-python #if you using are root environment", 
            "title": "Starting with Mysql"
        }, 
        {
            "location": "/web/#custom-view-8", 
            "text": "from rest_framework import mixins\n\n\nclass CreateModelMixin(object):\n     \n    Create a model instance.\n     \n    def create(self, request, *args, **kwargs):\n        event = request.data\n        try:\n            event['time'] = int(time.time())\n        except Exception, e:\n            print 'Set Time Error'\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n    def get_success_headers(self, data):\n        try:\n            return {'Location': data[api_settings.URL_FIELD_NAME]}\n        except (TypeError, KeyError):\n            return {}\n\nclass YourViewSet(CreateModelMixin,\n                  mixins.RetrieveModelMixin,\n                  mixins.UpdateModelMixin,\n                  mixins.DestroyModelMixin,\n                  mixins.ListModelMixin,\n                  GenericViewSet):\n    queryset = YourModel.objects.all()\n    serializer_class = YourModelSerializer", 
            "title": "Custom View 8"
        }, 
        {
            "location": "/web/#logging-settings", 
            "text": "Here is an example, put this settings dict into your  settings.py  file:  \nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'verbose': {\n            'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'\n        },\n        'simple': {\n            'format': '%(levelname)s %(message)s'\n        },\n    },\n    'filters': {\n        'special': {\n            '()': 'project.logging.SpecialFilter',\n            'foo': 'bar',\n        },\n        'require_debug_true': {\n            '()': 'django.utils.log.RequireDebugTrue',\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': 'INFO',\n            'filters': ['require_debug_true'],\n            'class': 'logging.StreamHandler',\n            'formatter': 'simple'\n        },\n        'mail_admins': {\n            'level': 'ERROR',\n            'class': 'django.utils.log.AdminEmailHandler',\n            'filters': ['special']\n        }\n    },\n    'loggers': {\n        'django': {\n            'handlers': ['console'],\n            'propagate': True,\n        },\n        'django.request': {\n            'handlers': ['mail_admins'],\n            'level': 'ERROR',\n            'propagate': False,\n        },\n        'myproject.custom': {\n            'handlers': ['console', 'mail_admins'],\n            'level': 'INFO',\n            'filters': ['special']\n        }\n    }\n}", 
            "title": "Logging settings"
        }, 
        {
            "location": "/web/#python-build-python-api-client-package", 
            "text": "", 
            "title": "Python: Build Python API Client package"
        }, 
        {
            "location": "/web/#step-1-write-document-on-swagger-editor1", 
            "text": "", 
            "title": "Step 1: Write document on Swagger Editor1"
        }, 
        {
            "location": "/web/#step-2-genenrate-client-python-save-python-clientzip", 
            "text": "", 
            "title": "Step 2: Genenrate Client --&gt; Python --&gt; save python-client.zip"
        }, 
        {
            "location": "/web/#step-3-extract-zip", 
            "text": "", 
            "title": "Step 3: Extract zip"
        }, 
        {
            "location": "/web/#step-4-open-project-in-pycharm-rename-project-directory-project-name-swagger_client-package", 
            "text": "", 
            "title": "Step 4: Open project in Pycharm rename project directory, project name, swagger_client package"
        }, 
        {
            "location": "/web/#step-5-2", 
            "text": "mkdir conda\ncd conda\ngit clone https://github.com/hunguyen1702/condaBuildLocalTemplate.git\nmv condaBuildLocalTemplate your_package_name\nrm -rf .git README.md", 
            "title": "Step 5: 2"
        }, 
        {
            "location": "/web/#step-6-edit-metayaml-file-in-your_package-folder", 
            "text": "", 
            "title": "Step 6: Edit meta.yaml file in your_package folder"
        }, 
        {
            "location": "/web/#61-follow-instruction-inside-metayaml", 
            "text": "", 
            "title": "6.1 Follow instruction inside meta.yaml"
        }, 
        {
            "location": "/web/#62-replace-these-line", 
            "text": "requirements:\n  build:\n    - python\n    - setuptools\n  run:\n    - python", 
            "title": "6.2 Replace these line"
        }, 
        {
            "location": "/web/#with", 
            "text": "requirements:\n  build:\n    - python\n    - setuptools\n    - six\n    - certifi\n    - python-dateutil\n  run:\n    - python\n    - six\n    - certifi\n    - python-dateutil", 
            "title": "with:"
        }, 
        {
            "location": "/web/#step-7", 
            "text": "cd ..\nconda build your_package", 
            "title": "Step 7:"
        }, 
        {
            "location": "/web/#step-8", 
            "text": "mkdir channel\ncd channel\nconda convert --platform all ~/anaconda/conda-bld/linux-64/your_package_0.1.0-py27_0.tar.bz2", 
            "title": "Step 8:"
        }, 
        {
            "location": "/web/#step-9-create-virtual-env", 
            "text": "name: your_env_name\ndependencies:\n- certifi=2016.2.28=py27_0\n- openssl=1.0.2h=0\n- pip=8.1.2=py27_0\n- python=2.7.11=0\n- python-dateutil=2.5.3=py27_0\n- readline=6.2=2\n- setuptools=20.7.0=py27_0\n- six=1.10.0=py27_0\n- tk=8.5.18=0\n- wheel=0.29.0=py27_0\n- zlib=1.2.8=0\n- pip:\n  - urllib3==1.15.1", 
            "title": "Step 9: Create virtual-env"
        }, 
        {
            "location": "/web/#step-10-install", 
            "text": "conda install --use-local your_package      Django    Writing your first Django app, part 1    Django REST framework: Installation    Django: Migrations    Building a Simple REST API for Mobile Applications    Django: Models    How to show object details in Django Rest Framework browseable API?    rest_framework:mixins", 
            "title": "Step 10: Install:"
        }, 
        {
            "location": "/logging/", 
            "text": "logging \n1\n  \n2\n  \n3\n\n\nlevels\n, \nattributes\n references\n\n\nThe logging library takes a modular approach and offers several categories of components: loggers, handlers, filters, and formatters.\n\n\n\n\nLoggers expose the interface that application code directly uses.\n\n\nHandlers send the log records (created by loggers) to the appropriate destination.\n\n\nFilters provide a finer grained facility for determining which log records to output.\n\n\nFormatters specify the layout of log records in the final output.\n\n\n\n\nStep 0: Project structure\n\n\ncode/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 config\n\u251c   \u2514\u2500\u2500 logging.conf\n\u2514\u2500\u2500 logs\n    \u2514\u2500\u2500 app.log\n\n\n\n\nStep 1: Create file \nlogging.conf\n\n\n[loggers]\nkeys=root\n\n[handlers]\nkeys=consoleHandler,fileHandler\n\n[formatters]\nkeys=formatter\n\n[logger_root]\nlevel=DEBUG\nhandlers=consoleHandler,fileHandler\n\n[handler_consoleHandler]\nclass=StreamHandler\nlevel=DEBUG\nformatter=formatter\nargs=(sys.stdout,)\n\n[handler_fileHandler]\nclass=FileHandler\nlevel=DEBUG\nformatter=formatter\nargs = ('logs/app.log','a')\n\n[formatter_formatter]\nformat=%(asctime)s - %(name)s - %(levelname)s - %(message)s\ndatefmt=\n\n\n\n\nStep 2: Load config and create logger\n\n\nIn \nmain.py\n\n\nimport logging.config\n\n# load logging config\nlogging.config.fileConfig('config/logging.conf')\n\n\n\n\nStep 3: In your application code\n\n\nlogging.getLogger().debug('debug message')\nlogging.getLogger().info('info message')\nlogging.getLogger().warn('warn message')\nlogging.getLogger().error('error message')\nlogging.getLogger().critical('critical message')\n\n\n\n\nMore Resources\n\n\n\n\nIntroduction to Logging\n\n\nQuick and simple usage of python log\n\n\n\n\n\n\n\n\n\n\n\n\nPython: Logging module\n\n\n\n\n\n\nPython: Logging cookbook\n\n\n\n\n\n\nPython: Logging guide", 
            "title": "Logging"
        }, 
        {
            "location": "/logging/#logging-1-2-3", 
            "text": "levels ,  attributes  references  The logging library takes a modular approach and offers several categories of components: loggers, handlers, filters, and formatters.   Loggers expose the interface that application code directly uses.  Handlers send the log records (created by loggers) to the appropriate destination.  Filters provide a finer grained facility for determining which log records to output.  Formatters specify the layout of log records in the final output.   Step 0: Project structure  code/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 config\n\u251c   \u2514\u2500\u2500 logging.conf\n\u2514\u2500\u2500 logs\n    \u2514\u2500\u2500 app.log  Step 1: Create file  logging.conf  [loggers]\nkeys=root\n\n[handlers]\nkeys=consoleHandler,fileHandler\n\n[formatters]\nkeys=formatter\n\n[logger_root]\nlevel=DEBUG\nhandlers=consoleHandler,fileHandler\n\n[handler_consoleHandler]\nclass=StreamHandler\nlevel=DEBUG\nformatter=formatter\nargs=(sys.stdout,)\n\n[handler_fileHandler]\nclass=FileHandler\nlevel=DEBUG\nformatter=formatter\nargs = ('logs/app.log','a')\n\n[formatter_formatter]\nformat=%(asctime)s - %(name)s - %(levelname)s - %(message)s\ndatefmt=  Step 2: Load config and create logger  In  main.py  import logging.config\n\n# load logging config\nlogging.config.fileConfig('config/logging.conf')  Step 3: In your application code  logging.getLogger().debug('debug message')\nlogging.getLogger().info('info message')\nlogging.getLogger().warn('warn message')\nlogging.getLogger().error('error message')\nlogging.getLogger().critical('critical message')  More Resources   Introduction to Logging  Quick and simple usage of python log       Python: Logging module    Python: Logging cookbook    Python: Logging guide", 
            "title": "logging 1  2  3"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\npyconfiguration\n\n\nInstallation\n\n\nconda install -c rain1024 pyconfiguration\n\n\n\n\nUsage\n\n\nStep 1: Create \nconfig.json\n file\n\n\n{\n  \nSERVICE_URL\n: \nhttp://api.service.com\n\n}\n\n\n\n\nStep 2: Add these code to \nmain.py\n file\n\n\nfrom pyconfiguration import Configuration\nConfiguration.load('config.json')\nprint Configuration.SERVICE_URL\n\n\n http://api.service.com\n\n\n\n\nReferences: What's the best practice using a settings file \n1\n\n\n\n\n\n\n\n\n\n\nWhat's the best practice using a settings file in Python?", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "pyconfiguration", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#installation", 
            "text": "conda install -c rain1024 pyconfiguration", 
            "title": "Installation"
        }, 
        {
            "location": "/configuration/#usage", 
            "text": "Step 1: Create  config.json  file  {\n   SERVICE_URL :  http://api.service.com \n}  Step 2: Add these code to  main.py  file  from pyconfiguration import Configuration\nConfiguration.load('config.json')\nprint Configuration.SERVICE_URL  http://api.service.com  References: What's the best practice using a settings file  1      What's the best practice using a settings file in Python?", 
            "title": "Usage"
        }, 
        {
            "location": "/command_line/", 
            "text": "Command Line Arguments\n\n\nThere are the following modules in the standard library:\n\n\n\n\nThe getopt module is similar to GNU getopt.\n\n\nThe optparse module offers object-oriented command line option parsing.\n\n\n\n\nHere is an example that uses the latter from the docs:\n\n\nfrom optparse import OptionParser\n\nparser = OptionParser()\nparser.add_option(\n-f\n, \n--file\n, dest=\nfilename\n,\n                  help=\nwrite report to FILE\n, metavar=\nFILE\n)\nparser.add_option(\n-q\n, \n--quiet\n,\n                  action=\nstore_false\n, dest=\nverbose\n, default=True,\n                  help=\ndon't print status messages to stdout\n)\n\n(options, args) = parser.parse_args()\n\n\n\n\noptparse supports (among other things):\n\n\n\n\nMultiple options in any order.\n\n\nShort and long options.\n\n\nDefault values.\n\n\nGeneration of a usage help message.\n\n\n\n\nSuggest Reading\n\n\n\n\nCommand Line Arguments In Python", 
            "title": "Command Line"
        }, 
        {
            "location": "/command_line/#command-line-arguments", 
            "text": "There are the following modules in the standard library:   The getopt module is similar to GNU getopt.  The optparse module offers object-oriented command line option parsing.   Here is an example that uses the latter from the docs:  from optparse import OptionParser\n\nparser = OptionParser()\nparser.add_option( -f ,  --file , dest= filename ,\n                  help= write report to FILE , metavar= FILE )\nparser.add_option( -q ,  --quiet ,\n                  action= store_false , dest= verbose , default=True,\n                  help= don't print status messages to stdout )\n\n(options, args) = parser.parse_args()  optparse supports (among other things):   Multiple options in any order.  Short and long options.  Default values.  Generation of a usage help message.", 
            "title": "Command Line Arguments"
        }, 
        {
            "location": "/command_line/#suggest-reading", 
            "text": "Command Line Arguments In Python", 
            "title": "Suggest Reading"
        }, 
        {
            "location": "/test/", 
            "text": "Testing your code is very important.\n\n\n\n\nGetting used to writing testing code and running this code in parallel is now considered a good habit. Used wisely, this method helps you define more precisely your code\u2019s intent and have a more decoupled architecture.\n\n\nUnittest\n\n\nunittest is the batteries-included test module in the Python standard library. Its API will be familiar to anyone who has used any of the JUnit/nUnit/CppUnit series of tools.\n\n\nThe Basics\n\n\nCreating test cases is accomplished by subclassing unittest.TestCase.\n\n\nimport unittest\n\ndef fun(x):\n    return x + 1\n\nclass MyTest(unittest.TestCase):\n    def test(self):\n        self.assertEqual(fun(3), 4)\n\n\n\n\nSkipping tests\n\n\nUnittest supports skipping individual test methods and even whole classes of tests. In addition, it supports marking a test as an \u201cexpected failure,\u201d a test that is broken and will fail, but shouldn\u2019t be counted as a failure on a .code \nTestResult\n.\n\n\nSkipping a test is simply a matter of using the \nskip() decorator\n or one of its conditional variants.\n\n\nimport sys\nimport unittest\n\nclass MyTestCase(unittest.TestCase):\n\n    @unittest.skip(\ndemonstrating skipping\n)\n    def test_nothing(self):\n        self.fail(\nshouldn't happen\n)\n\n    @unittest.skipIf(mylib.__version__ \n (1, 3),\n                     \nnot supported in this library version\n)\n    def test_format(self):\n        # Tests that work for only a certain version of the library.\n        pass\n\n    @unittest.skipUnless(sys.platform.startswith(\nwin\n), \nrequires Windows\n)\n    def test_windows_support(self):\n        # windows specific testing code\n        pass\n\n\n\n\nTox\n\n\ntox aims to automate and standardize testing in Python. It is part of a larger vision of easing the packaging, testing and release process of Python software.\n\n\nTox is a generic virtualenv management and test command line tool you can use for:\n\n\n\n\nchecking your package installs correctly with \ndifferent Python versions\n and interpreters\n\n\nrunning your tests in each of the environments, configuring your test tool of choice\n\n\nacting as a frontend to Continuous Integration servers, greatly reducing boilerplate and merging CI and shell-based testing.\n\n\n\n\nInstallation\n\n\nYou can install tox with pip using the following command\n\n\n$ pip install tox\n\n\n\n\nSetup default environment in Windows with conda\n\n\n$ conda create -p C:\\python27 python=2.7 \n$ conda create -p C:\\python34 python=3.4\n\n\n\n\nRelated Readings\n\n\n\n\nTesting Your Code, \nThe Hitchhiker's Guide to Python\n\n\nunittest \u2014 Unit testing framework, \ndocs.python.org\n\n\nIs it possible to use tox with conda-based Python installations?, \nstackoverflow", 
            "title": "Testing"
        }, 
        {
            "location": "/test/#unittest", 
            "text": "unittest is the batteries-included test module in the Python standard library. Its API will be familiar to anyone who has used any of the JUnit/nUnit/CppUnit series of tools.", 
            "title": "Unittest"
        }, 
        {
            "location": "/test/#the-basics", 
            "text": "Creating test cases is accomplished by subclassing unittest.TestCase.  import unittest\n\ndef fun(x):\n    return x + 1\n\nclass MyTest(unittest.TestCase):\n    def test(self):\n        self.assertEqual(fun(3), 4)", 
            "title": "The Basics"
        }, 
        {
            "location": "/test/#skipping-tests", 
            "text": "Unittest supports skipping individual test methods and even whole classes of tests. In addition, it supports marking a test as an \u201cexpected failure,\u201d a test that is broken and will fail, but shouldn\u2019t be counted as a failure on a .code  TestResult .  Skipping a test is simply a matter of using the  skip() decorator  or one of its conditional variants.  import sys\nimport unittest\n\nclass MyTestCase(unittest.TestCase):\n\n    @unittest.skip( demonstrating skipping )\n    def test_nothing(self):\n        self.fail( shouldn't happen )\n\n    @unittest.skipIf(mylib.__version__   (1, 3),\n                      not supported in this library version )\n    def test_format(self):\n        # Tests that work for only a certain version of the library.\n        pass\n\n    @unittest.skipUnless(sys.platform.startswith( win ),  requires Windows )\n    def test_windows_support(self):\n        # windows specific testing code\n        pass", 
            "title": "Skipping tests"
        }, 
        {
            "location": "/test/#tox", 
            "text": "tox aims to automate and standardize testing in Python. It is part of a larger vision of easing the packaging, testing and release process of Python software.  Tox is a generic virtualenv management and test command line tool you can use for:   checking your package installs correctly with  different Python versions  and interpreters  running your tests in each of the environments, configuring your test tool of choice  acting as a frontend to Continuous Integration servers, greatly reducing boilerplate and merging CI and shell-based testing.   Installation  You can install tox with pip using the following command  $ pip install tox  Setup default environment in Windows with conda  $ conda create -p C:\\python27 python=2.7 \n$ conda create -p C:\\python34 python=3.4", 
            "title": "Tox"
        }, 
        {
            "location": "/test/#related-readings", 
            "text": "Testing Your Code,  The Hitchhiker's Guide to Python  unittest \u2014 Unit testing framework,  docs.python.org  Is it possible to use tox with conda-based Python installations?,  stackoverflow", 
            "title": "Related Readings"
        }, 
        {
            "location": "/ide/", 
            "text": "Today, I write some notes about my favorite Python IDE - \nPyCharm\n.\u00a0I believe it's a good one for developing python, which supports git, vim, etc. This list below contains my favorite features.\n\n\nPycharm Features\n\n\n\n\nIntelligent Editor\n\n\nNavigation\n\n\nGraphical Debugger\n\n\nRefactorings\n\n\nCode Inspections\n\n\nVersion Control Integration\n\n\nScientific Tools\n\n\n\n\nIntelligent Editor\n\n\nPyCharm provides smart code completion, code inspections, on-the-fly error highlighting and quick-fixes, along with automated code refactorings and rich navigation capabilities.\n\n\n\n\nSyntax Highlighting\n\n\nRead your code easier with customizable colors for Python code and Django templates. Choose from several predefined color themes.\n\n\nAuto-Identation and code formating\n\n\nAutomatic indents are inserted on new line. Indent verification and code re-formatting are compliant with project code-style settings.\n\n\nConfigurable code styles\n\n\nSelect a predefined coding style to apply to your code style configuration for various supported languages.\n\n\nCode completion\n\n\nCode completion for keywords, classes, variables, etc. as you type or via Ctrl+Space. Editor suggestions are context-aware and offer the most appropriate options.\n\n\nKeyboard shortcuts: \nTab\n, \nAlt+Enter\n\n\nCode selection and comments\n\n\nSelect a block of code and expand it to an expression, to a line, to a logical block of code, and so on with shortcuts. Single keystroke to comment/uncomment the current line or selection.\n\n\nCode formatter\n\n\nCode formatter with code style configuration and other features help you write neat code that's easy to support. PyCharm contains built-in PEP-8 for Python and other standards compliant code formatting for supported languages.\n\n\nCode snippets and templates\n\n\nSave time using advanced customizable and parametrized live code templates and snippets.\n\n\n\n\nKeyboard shortcuts \ncheck.if ENTER\n\n\nif check:\n  type_something\n\n\n\n\nCode folding\n\n\nCode folding, auto-insertion of braces, brackets \n quotes, matching brace/bracket highlighting, etc.\n\n\nOn-the-fly error highlighting\n\n\nErrors are shown as you type. The integrated spell-checker verifies your identifiers and comments for misspellings.\n\n\nMultiple carets and selections\n\n\nWith multiple carets, you can edit several locations in your file at the same time.\n\n\nKeyboard shortcuts: \nSHIFT + F6\n\n\nCode analysis\n\n\nNumerous code inspections verify Python code as you type and also allow inspecting the whole project for possible errors or code smells.\n\n\nQuick-fixes\n\n\nQuick-fixes for most inspections make it easy to fix or improve the code instantly. Alt+Enter shows appropriate options for each inspection.\n\n\nKeyboard shortcuts: \nF2\n\n\nDuplicated code detector\n\n\nSmart duplicated code detector analyzes your code and searches for copy/pasted code. You'll be presented with a list of candidates for refactoring\u2014and with the help of refactorings it's easy to keep your code dry.\n\n\nConfigurable language injections\n\n\nNatively edit non-Python code embedded into string literals, with code completion, error-highlighting, and other coding assistance features.\n\n\nCode auto generation\n\n\nCode auto-generation from usage with quick-fixes; docstrings and the code matching verification, plus autoupdate on refactoring. Automatic generation of a docstring stub (reStructuredText, Epytext, Google, and NumPy).\n\n\nIntention actions\n\n\nIntention actions help you apply automated changes to code that is correct, to improve it or to make your coding routine easier.\n\n\nSearching\n\n\nKeyboard shortcuts: \nDouble Shift\n (search everywhere)\n\n\nNavigation\n\n\nShortcuts\n\n\nKeyboard shortcuts: \nALT + SHIFT + UP/DOWN\n (move line up and down)\n\n\nGraphical Debugger\n\n\nPyCharm provides extensive options for debugging your Python/Django and JavaScript code:\n\n\n\n\nSet breakpoints right inside the editor and define hit conditions\n\n\nInspect context-relevant local variables and user-defined watches, including arrays and complex objects, and edit values on the fly\n\n\nSet up remote debugging using remote interpreters\n\n\nEvaluate an expression in runtime and collect run-time type statistics for better autocompletion and code inspections\n\n\nAttach to a running process\n\n\nDebug Django templates\n\n\n\n\n\n\nInline Debugger\n\n\nWith an inline debugger, all live debugging data are shown directly in the editor, with variable values integrated into the editor's look-and-feel. Variable values can be viewed in the source code, right next to their usages.\n\n\nStep into My Code\n\n\nUse Step into My Code to stay focused on your code: the debugger will only step through your code bypassing any library sources.\n\n\nMulti-process debugging\n\n\nPyCharm can debug applications that spawn multiple Python processes, such as Django applications that don't run in --no-reload mode, or applications using many other Web frameworks that use a similar approach to code auto-reloading.\n\n\nRun/Debug configurations\n\n\nEvery script/test or debugger execution creates a special 'Run/Debug Configuration' that can be edited and used later. Run/Debug Configurations can be shared with project settings for use by the whole team.\n\n\nWorkspace\n\n\nCustom\u00a0Scheme\n\n\n\nGo to \nFile - Settings...\n then \nEditor - Colors Fonts\n\n\nNow you can change your scheme, I like \nDarcular\n\n\n\n\nIPython Support\n\n\nPyCharm supports usage of IPython magic commands.\n\n\n\n\nVim Support\n\n\nYou can configure PyCharm to work as a Vim editor\n\n\n\n\nKeyboard Shortcuts: \nCtrl+Shift+V\n (paste)", 
            "title": "IDE & Debugging"
        }, 
        {
            "location": "/ide/#pycharm-features", 
            "text": "Intelligent Editor  Navigation  Graphical Debugger  Refactorings  Code Inspections  Version Control Integration  Scientific Tools", 
            "title": "Pycharm Features"
        }, 
        {
            "location": "/ide/#intelligent-editor", 
            "text": "PyCharm provides smart code completion, code inspections, on-the-fly error highlighting and quick-fixes, along with automated code refactorings and rich navigation capabilities.   Syntax Highlighting  Read your code easier with customizable colors for Python code and Django templates. Choose from several predefined color themes.  Auto-Identation and code formating  Automatic indents are inserted on new line. Indent verification and code re-formatting are compliant with project code-style settings.  Configurable code styles  Select a predefined coding style to apply to your code style configuration for various supported languages.  Code completion  Code completion for keywords, classes, variables, etc. as you type or via Ctrl+Space. Editor suggestions are context-aware and offer the most appropriate options.  Keyboard shortcuts:  Tab ,  Alt+Enter  Code selection and comments  Select a block of code and expand it to an expression, to a line, to a logical block of code, and so on with shortcuts. Single keystroke to comment/uncomment the current line or selection.  Code formatter  Code formatter with code style configuration and other features help you write neat code that's easy to support. PyCharm contains built-in PEP-8 for Python and other standards compliant code formatting for supported languages.  Code snippets and templates  Save time using advanced customizable and parametrized live code templates and snippets.   Keyboard shortcuts  check.if ENTER  if check:\n  type_something  Code folding  Code folding, auto-insertion of braces, brackets   quotes, matching brace/bracket highlighting, etc.  On-the-fly error highlighting  Errors are shown as you type. The integrated spell-checker verifies your identifiers and comments for misspellings.  Multiple carets and selections  With multiple carets, you can edit several locations in your file at the same time.  Keyboard shortcuts:  SHIFT + F6  Code analysis  Numerous code inspections verify Python code as you type and also allow inspecting the whole project for possible errors or code smells.  Quick-fixes  Quick-fixes for most inspections make it easy to fix or improve the code instantly. Alt+Enter shows appropriate options for each inspection.  Keyboard shortcuts:  F2  Duplicated code detector  Smart duplicated code detector analyzes your code and searches for copy/pasted code. You'll be presented with a list of candidates for refactoring\u2014and with the help of refactorings it's easy to keep your code dry.  Configurable language injections  Natively edit non-Python code embedded into string literals, with code completion, error-highlighting, and other coding assistance features.  Code auto generation  Code auto-generation from usage with quick-fixes; docstrings and the code matching verification, plus autoupdate on refactoring. Automatic generation of a docstring stub (reStructuredText, Epytext, Google, and NumPy).  Intention actions  Intention actions help you apply automated changes to code that is correct, to improve it or to make your coding routine easier.  Searching  Keyboard shortcuts:  Double Shift  (search everywhere)", 
            "title": "Intelligent Editor"
        }, 
        {
            "location": "/ide/#navigation", 
            "text": "Shortcuts  Keyboard shortcuts:  ALT + SHIFT + UP/DOWN  (move line up and down)", 
            "title": "Navigation"
        }, 
        {
            "location": "/ide/#graphical-debugger", 
            "text": "PyCharm provides extensive options for debugging your Python/Django and JavaScript code:   Set breakpoints right inside the editor and define hit conditions  Inspect context-relevant local variables and user-defined watches, including arrays and complex objects, and edit values on the fly  Set up remote debugging using remote interpreters  Evaluate an expression in runtime and collect run-time type statistics for better autocompletion and code inspections  Attach to a running process  Debug Django templates    Inline Debugger  With an inline debugger, all live debugging data are shown directly in the editor, with variable values integrated into the editor's look-and-feel. Variable values can be viewed in the source code, right next to their usages.  Step into My Code  Use Step into My Code to stay focused on your code: the debugger will only step through your code bypassing any library sources.  Multi-process debugging  PyCharm can debug applications that spawn multiple Python processes, such as Django applications that don't run in --no-reload mode, or applications using many other Web frameworks that use a similar approach to code auto-reloading.  Run/Debug configurations  Every script/test or debugger execution creates a special 'Run/Debug Configuration' that can be edited and used later. Run/Debug Configurations can be shared with project settings for use by the whole team.", 
            "title": "Graphical Debugger"
        }, 
        {
            "location": "/ide/#workspace", 
            "text": "", 
            "title": "Workspace"
        }, 
        {
            "location": "/ide/#ipython-support", 
            "text": "PyCharm supports usage of IPython magic commands.", 
            "title": "IPython Support"
        }, 
        {
            "location": "/ide/#vim-support", 
            "text": "You can configure PyCharm to work as a Vim editor   Keyboard Shortcuts:  Ctrl+Shift+V  (paste)", 
            "title": "Vim Support"
        }, 
        {
            "location": "/package_manager/", 
            "text": "py2exe\n\n\npy2exe is a Python Distutils extension which converts Python scripts into executable Windows programs, able to run without requiring a Python installation.Spice\n\n\nInstallation\n\n\n# py2exe\nconda install -c https://conda.anaconda.org/clinicalgraphics cg-py2exe\n\n\n\n\nBuild \n1\n\n\npython setup.py py2exe\n# build PyQT\npython setup.py py2exe --includes sip\n\n\n\n\nKnown Issues\n\n\nError: Microsoft Visual C++ 10.0 is required (Unable to find vcvarsall.bat) (\nlink\n)\n\n\nHow to fix\n\n\nStep 1: Install Visual Studio 2015\n\n\nStep 2:\n\n\nset VS100COMNTOOLS=%VS140COMNTOOLS%\n\n\n\n\n\n\n\n\n\n\n\n\nhttp://www.py2exe.org/index.cgi/Py2exeAndPyQt", 
            "title": "Package Manager"
        }, 
        {
            "location": "/package_manager/#py2exe", 
            "text": "py2exe is a Python Distutils extension which converts Python scripts into executable Windows programs, able to run without requiring a Python installation.Spice", 
            "title": "py2exe"
        }, 
        {
            "location": "/package_manager/#installation", 
            "text": "# py2exe\nconda install -c https://conda.anaconda.org/clinicalgraphics cg-py2exe", 
            "title": "Installation"
        }, 
        {
            "location": "/package_manager/#build-1", 
            "text": "python setup.py py2exe\n# build PyQT\npython setup.py py2exe --includes sip", 
            "title": "Build 1"
        }, 
        {
            "location": "/package_manager/#known-issues", 
            "text": "Error: Microsoft Visual C++ 10.0 is required (Unable to find vcvarsall.bat) ( link )  How to fix  Step 1: Install Visual Studio 2015  Step 2:  set VS100COMNTOOLS=%VS140COMNTOOLS%      http://www.py2exe.org/index.cgi/Py2exeAndPyQt", 
            "title": "Known Issues"
        }, 
        {
            "location": "/environment/", 
            "text": "Environment Management\n\n\nSimilar to pip, conda is an open source package and environment management system \n1\n. Anaconda is a data science platform that comes with a lot of packages. It uses conda at the core. Unlike Anaconda, Miniconda doesn't come with any installed packages by default. Note that for miniconda, everytime you open up a terminal, conda won\u2019t automatically be available. Run the command below to use conda within miniconda.\n\n\nConda\n\n\nLet\u2019s first start by checking if conda is installed.\n\n\n$ conda --version\n\nconda 4.2.12\n\n\n\n\nTo see the full documentation for any command, type the command followed by --help. For example, to learn about the conda update command:\n\n\n$ conda update --help\n\n\n\n\nOnce it has been confirmed that conda has been installed, we will now make sure that it is up to date.\n\n\n$ conda update conda\n\nUsing Anaconda Cloud api site https://api.anaconda.org\nFetching package metadata: ....\n.Solving package specifications: .........\n\nPackage plan for installation in environment //anaconda:\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    conda-env-2.6.0            |                0          601 B\n    ruamel_yaml-0.11.14        |           py27_0         184 KB\n    conda-4.2.12               |           py27_0         376 KB\n    ------------------------------------------------------------\n                                           Total:         560 KB\n\nThe following NEW packages will be INSTALLED:\n\n    ruamel_yaml: 0.11.14-py27_0\n\nThe following packages will be UPDATED:\n\n    conda:       4.0.7-py27_0 --\n 4.2.12-py27_0\n    conda-env:   2.4.5-py27_0 --\n 2.6.0-0\n    python:      2.7.11-0     --\n 2.7.12-1\n    sqlite:      3.9.2-0      --\n 3.13.0-0\n\nProceed ([y]/n)? y\n\nFetching packages ...\nconda-env-2.6. 100% |################################| Time: 0:00:00 360.78 kB/s\nruamel_yaml-0. 100% |################################| Time: 0:00:00   5.53 MB/s\nconda-4.2.12-p 100% |################################| Time: 0:00:00   5.84 MB/s\nExtracting packages ...\n[      COMPLETE      ]|###################################################| 100%\nUnlinking packages ...\n[      COMPLETE      ]|###################################################| 100%\nLinking packages ...\n[      COMPLETE      ]|###################################################| 100%\n\n\n\n\nEnvironments\n\n\nCreate\n\n\nIn order to manage environments, we need to create at least two so you can move or switch between them. To create a new environment, use the conda create command, followed by any name you wish to call it:\n\n\n# create new environment\nconda create -n \nyour_environment\n python=2.7.11\n\n\n\n\nClone\n\n\nMake an exact copy of an environment by creating a clone of it. Here we will clone snowflakes to create an exact copy named flowers:\n\n\nconda create --name flowers --clone snowflakes\n\n\n\n\nList\n\n\nList all environments\n\n\nNow you can use conda to see which environments you have installed so far. Use the conda environment info command to find out\n\n\n$ conda info -e\n\nconda environments:\nsnowflakes            /home/username/miniconda/envs/snowflakes\nbunnies               /home/username/miniconda/envs/bunnies\n\n\n\n\nVerify current environment\n\n\nWhich environment are you using right now \u2013 snowflakes or bunnies? To find out, type the command:\n\n\nconda info --envs\n\n\n\n\nRemove\n\n\nIf you didn\u2019t really want an environment named flowers, just remove it as follows:\n\n\nconda remove --name flowers --all\n\n\n\n\nShare\n\n\nYou may want to share your environment with another person, for example, so they can re-create a test that you have done. To allow them to quickly reproduce your environment, with all of its packages and versions, you can give them a copy of your environment.yml file.\n\n\nExport the environment file\n\n\nTo enable another person to create an exact copy of your environment, you will export the active environment file.\n\n\nconda env export \n environment.yml\n\n\n\n\nUse environment from file\n\n\nCreate a copy of another developer\u2019s environment from their environment.yml file:\n\n\nconda env create -f environment.yml\n\n\n\n\n# remove environment\nconda remove -n \nyour_environemnt\n --all\n\n\n\n\n\n\n\n\n\n\n\n\nConda, Managing environments", 
            "title": "Environment"
        }, 
        {
            "location": "/environment/#environment-management", 
            "text": "Similar to pip, conda is an open source package and environment management system  1 . Anaconda is a data science platform that comes with a lot of packages. It uses conda at the core. Unlike Anaconda, Miniconda doesn't come with any installed packages by default. Note that for miniconda, everytime you open up a terminal, conda won\u2019t automatically be available. Run the command below to use conda within miniconda.", 
            "title": "Environment Management"
        }, 
        {
            "location": "/environment/#conda", 
            "text": "Let\u2019s first start by checking if conda is installed.  $ conda --version\n\nconda 4.2.12  To see the full documentation for any command, type the command followed by --help. For example, to learn about the conda update command:  $ conda update --help  Once it has been confirmed that conda has been installed, we will now make sure that it is up to date.  $ conda update conda\n\nUsing Anaconda Cloud api site https://api.anaconda.org\nFetching package metadata: ....\n.Solving package specifications: .........\n\nPackage plan for installation in environment //anaconda:\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    conda-env-2.6.0            |                0          601 B\n    ruamel_yaml-0.11.14        |           py27_0         184 KB\n    conda-4.2.12               |           py27_0         376 KB\n    ------------------------------------------------------------\n                                           Total:         560 KB\n\nThe following NEW packages will be INSTALLED:\n\n    ruamel_yaml: 0.11.14-py27_0\n\nThe following packages will be UPDATED:\n\n    conda:       4.0.7-py27_0 --  4.2.12-py27_0\n    conda-env:   2.4.5-py27_0 --  2.6.0-0\n    python:      2.7.11-0     --  2.7.12-1\n    sqlite:      3.9.2-0      --  3.13.0-0\n\nProceed ([y]/n)? y\n\nFetching packages ...\nconda-env-2.6. 100% |################################| Time: 0:00:00 360.78 kB/s\nruamel_yaml-0. 100% |################################| Time: 0:00:00   5.53 MB/s\nconda-4.2.12-p 100% |################################| Time: 0:00:00   5.84 MB/s\nExtracting packages ...\n[      COMPLETE      ]|###################################################| 100%\nUnlinking packages ...\n[      COMPLETE      ]|###################################################| 100%\nLinking packages ...\n[      COMPLETE      ]|###################################################| 100%", 
            "title": "Conda"
        }, 
        {
            "location": "/environment/#environments", 
            "text": "", 
            "title": "Environments"
        }, 
        {
            "location": "/environment/#create", 
            "text": "In order to manage environments, we need to create at least two so you can move or switch between them. To create a new environment, use the conda create command, followed by any name you wish to call it:  # create new environment\nconda create -n  your_environment  python=2.7.11", 
            "title": "Create"
        }, 
        {
            "location": "/environment/#clone", 
            "text": "Make an exact copy of an environment by creating a clone of it. Here we will clone snowflakes to create an exact copy named flowers:  conda create --name flowers --clone snowflakes", 
            "title": "Clone"
        }, 
        {
            "location": "/environment/#list", 
            "text": "List all environments  Now you can use conda to see which environments you have installed so far. Use the conda environment info command to find out  $ conda info -e\n\nconda environments:\nsnowflakes            /home/username/miniconda/envs/snowflakes\nbunnies               /home/username/miniconda/envs/bunnies  Verify current environment  Which environment are you using right now \u2013 snowflakes or bunnies? To find out, type the command:  conda info --envs", 
            "title": "List"
        }, 
        {
            "location": "/environment/#remove", 
            "text": "If you didn\u2019t really want an environment named flowers, just remove it as follows:  conda remove --name flowers --all", 
            "title": "Remove"
        }, 
        {
            "location": "/environment/#share", 
            "text": "You may want to share your environment with another person, for example, so they can re-create a test that you have done. To allow them to quickly reproduce your environment, with all of its packages and versions, you can give them a copy of your environment.yml file.  Export the environment file  To enable another person to create an exact copy of your environment, you will export the active environment file.  conda env export   environment.yml  Use environment from file  Create a copy of another developer\u2019s environment from their environment.yml file:  conda env create -f environment.yml  # remove environment\nconda remove -n  your_environemnt  --all      Conda, Managing environments", 
            "title": "Share"
        }, 
        {
            "location": "/module/", 
            "text": "Create Public Module\n\n\nconda\n, \npypi\n, \ngithub\n\n\nStep 0/4: Check your package name\n\n\nGo to \nhttps://pypi.python.org/pypi/your_package_name\n to see your package name is valid\n\n\nStep 1/4: Make your module \n1\n\n\n1.1\n \npip install cookiecutter\n\n\n1.2\n \ncookiecutter https://github.com/audreyr/cookiecutter-pypackage.git\n\n\n1.3\n Fill all necessary information\n\n\nfull_name [Audrey Roy Greenfeld]:\nemail [aroy@alum.mit.edu]:\ngithub_username [audreyr]:\nproject_name [Python Boilerplate]:\nproject_slug []:\nproject_short_description:\nrelease_date []:\npypi_username []:\nyear [2016]:\nversion [0.1.0]:\nuse_pypi_deployment_with_travis [y]:\n\n\n\n\nIt will create a directory\n\n\n|- LICENSE\n|- README.md\n|- TODO.md\n|- docs\n|   |-- conf.py\n|   |-- generated\n|   |-- index.rst\n|   |-- installation.rst\n|   |-- modules.rst\n|   |-- quickstart.rst\n|   |-- sandman.rst\n|- requirements.txt\n|- your_package\n|   |-- __init__.py\n|   |-- your_package.py\n|   |-- test\n|       |-- models.py\n|       |-- test_your_package.py\n|- setup.py\n\n\n\n\nStep 2/4: Git\n\n\nStep 3/4: Pypi \n3\n\n\n1.\n Create your Pypi Account\n\n\n2.\n Create a \n.pypirc\n configuration file in \n$HOME\n directory\n\n\n[distutils]\nindex-servers =\n  pypi\n\n[pypi]\nrepository=https://pypi.python.org/pypi\nusername=your_username\npassword=your_password\n\n\n\n\n3.\n Change your \nMANIFEST.in\n\n\nrecursive-include project_folder *\n\n\n\n\n4.\n Upload your package to PyPI\n\n\npython setup.py register -r pypi\npython setup.py sdist upload -r pypi\n\n\n\n\nStep 4/4: Conda \n2\n\n\n1.\n Install conda tools\n\n\nconda install conda-build\nconda install anaconda-client\n\n\n\n\n2.\n Build a simple package with conda skeleton pypi\n\n\ncd your_package_folder\nmkdir conda\ncd conda\nconda skeleton pypi your_package\n\n\n\n\nThis creates a directory named \nyour_package\n and three skeleton files in that directory\n\n\n|- your_package\n|   |-- bld.bat\n|   |-- meta.yaml\n|   |-- build.sh\n\n\n\n\n3.\n Build your package\n\n\nconda build your_package\n\n# convert to all platform\nconda convert -f --platform all\n  C:\\Anaconda\\conda-bld\\win-64\\your_package-0.1.1-py27_0.tar.bz2\n\n\n\n\n4.\n Upload packages to Anaconda\n\n\nanaconda login\nanaconda upload linux-32/your_package.tar.bz2\nanaconda upload linux-64/your_package.tar.bz2\nanaconda upload win-32/your_package.tar.bz2\nanaconda upload win-64/your_package.tar.bz2\n\n\n\n\nCreate Private Module\n\n\nStep 1: Make your module \n1\n\n\n1.1\n \npip install cookiecutter\n\n\n1.2\n \ncookiecutter https://github.com/audreyr/cookiecutter-pypackage.git\n\n\n1.3\n Fill all necessary information\n\n\nfull_name [Audrey Roy Greenfeld]:\nemail [aroy@alum.mit.edu]:\ngithub_username [audreyr]:\nproject_name [Python Boilerplate]:\nproject_slug []:\nproject_short_description:\nrelease_date []:\npypi_username []:\nyear [2016]:\nversion [0.1.0]:\nuse_pypi_deployment_with_travis [y]:\n\n\n\n\nStep 2: Build your module\n\n\nChange your \nMANIFEST.in\n\n\nrecursive-include project_folder *\n\n\n\n\nBuild your module with setup.py\n\n\ncd your_project_folder\n\n# build local\npython setup.py build\n\n It will create a new folder in\n\n $PYTHON_HOME/Lib/sites-packages/your_project_name-0.1.0-py2.7.egg\n\n# build distribution\npython setup.py sdist\n\n It will create a zip file in $PROJECT_FOLDER/dist\n\n\n\n\nStep 3: Usage your module\n\n\nIn the same machine\n\n\nimport your_project_name\n\n\n\n\nIn other machine\n\n\n\n\n\nPython: Build \n Install Local Package with Conda\n\n\nHere is a step by step tutorial about building a local module package \n install it from a custom channel \n1\n\n\nStep 1: Make a setup folder for your package with \ncookkiecutter\n\n\non terminal:\n\n\n\nmkdir build\ncd build\npip install cookiecutter\ncookiecutter https://github.com/audreyr/cookiecutter-pypackage.git\n\n\n\n\n\nFill all necessary information\n\n\nfull_name [Audrey Roy Greenfeld]:\nemail [aroy@alum.mit.edu]:\ngithub_username [audreyr]:\nproject_name [Python Boilerplate]:\nproject_slug []:\nproject_short_description:\nrelease_date []:\npypi_username []:\nyear [2016]:\nversion [0.1.0]:\nuse_pypi_deployment_with_travis [y]:\n\n\n\n\nIt will create a directory\n\n\n|- LICENSE\n|- README.md\n|- TODO.md\n|- docs\n|   |-- conf.py\n|   |-- generated\n|   |-- index.rst\n|   |-- installation.rst\n|   |-- modules.rst\n|   |-- quickstart.rst\n|   |-- sandman.rst\n|- requirements.txt\n|- your_package\n|   |-- __init__.py\n|   |-- your_package.py\n|   |-- test\n|       |-- models.py\n|       |-- test_your_package.py\n|- setup.py\n\n\n\n\nCopy your real package into directory above \n replace the package has been generated by\n\ncookkiecutter\n\n\nAdd this line to \nMANIFEST.in\n\n\nrecursive-include project_folder *\n\n\n\n\nStep 2: Build conda package\n\n\nmkdir conda\ncd conda\nmkdir channel\ngit clone https://github.com/hunguyen1702/condaBuildLocalTemplate.git\nmv condaBuildLocalTemplate your_package_name #Which ones you have filled in `project_name` above\ncd your_package_name\nrm -rf .git README.md\n\n\n\n\nEdit the file \nmeta.yaml\n with the instruction inside it\n\n\ncd ..\nconda build your_package_name\n\n\n\n\nStep 3: Create custom channel and install from local package\n\n\nCreate a channel directory\n\n\ncd channel\n\n\n\n\nConvert your_package you've built to all platform\n\n\nconda convert --platform all ~/anaconda/conda-bld/linux-64/your_package_0.1.0-py27_0.tar.bz2\n\n\n\n\nand this will create:\n\n\nchannel/\nlinux-64/\n   package-1.0-0.tar.bz2\nlinux-32/\n   package-1.0-0.tar.bz2\nosx-64/\n   package-1.0-0.tar.bz2\nwin-64/\n   package-1.0-0.tar.bz2\nwin-32/\n   package-1.0-0.tar.bz2\n\n\n\n\nRegister your package to your new channel\n\n\ncd ..\nconda index channel/linux-64 channel/osx-64 channel/win-64\n\n\n\n\nVeriy your new channel\n\n\nconda search -c file://path/to/channel/ --override-channels\n\n\n\n\nIf you see \nyour_package\n's appearance, so it's worked\n\n\nAfter that if you want to install that package from local, run this command:\n\n\n\nconda install --use-local your_package\n\n\n\n\n\nand when you want to create environment with local package from file, you just have export environment to \n.yml\n file and add this \nchannels\n section before the \ndependencies\n section:\n\n\n\nchannels:\n- file://path/to/your/channel/\n\n\n\n\n\n\n\n\n\n\n\n\n\nOpen Sourcing a Python Project the Right Way\n\n\n\n\n\n\nBuilding conda packages with conda skeleton\n\n\n\n\n\n\nHow to submit a package to PyPI", 
            "title": "Module"
        }, 
        {
            "location": "/module/#create-public-module", 
            "text": "conda ,  pypi ,  github", 
            "title": "Create Public Module"
        }, 
        {
            "location": "/module/#step-04-check-your-package-name", 
            "text": "Go to  https://pypi.python.org/pypi/your_package_name  to see your package name is valid", 
            "title": "Step 0/4: Check your package name"
        }, 
        {
            "location": "/module/#step-14-make-your-module-1", 
            "text": "1.1   pip install cookiecutter  1.2   cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git  1.3  Fill all necessary information  full_name [Audrey Roy Greenfeld]:\nemail [aroy@alum.mit.edu]:\ngithub_username [audreyr]:\nproject_name [Python Boilerplate]:\nproject_slug []:\nproject_short_description:\nrelease_date []:\npypi_username []:\nyear [2016]:\nversion [0.1.0]:\nuse_pypi_deployment_with_travis [y]:  It will create a directory  |- LICENSE\n|- README.md\n|- TODO.md\n|- docs\n|   |-- conf.py\n|   |-- generated\n|   |-- index.rst\n|   |-- installation.rst\n|   |-- modules.rst\n|   |-- quickstart.rst\n|   |-- sandman.rst\n|- requirements.txt\n|- your_package\n|   |-- __init__.py\n|   |-- your_package.py\n|   |-- test\n|       |-- models.py\n|       |-- test_your_package.py\n|- setup.py", 
            "title": "Step 1/4: Make your module 1"
        }, 
        {
            "location": "/module/#step-24-git", 
            "text": "", 
            "title": "Step 2/4: Git"
        }, 
        {
            "location": "/module/#step-34-pypi-3", 
            "text": "1.  Create your Pypi Account  2.  Create a  .pypirc  configuration file in  $HOME  directory  [distutils]\nindex-servers =\n  pypi\n\n[pypi]\nrepository=https://pypi.python.org/pypi\nusername=your_username\npassword=your_password  3.  Change your  MANIFEST.in  recursive-include project_folder *  4.  Upload your package to PyPI  python setup.py register -r pypi\npython setup.py sdist upload -r pypi", 
            "title": "Step 3/4: Pypi 3"
        }, 
        {
            "location": "/module/#step-44-conda-2", 
            "text": "1.  Install conda tools  conda install conda-build\nconda install anaconda-client  2.  Build a simple package with conda skeleton pypi  cd your_package_folder\nmkdir conda\ncd conda\nconda skeleton pypi your_package  This creates a directory named  your_package  and three skeleton files in that directory  |- your_package\n|   |-- bld.bat\n|   |-- meta.yaml\n|   |-- build.sh  3.  Build your package  conda build your_package\n\n# convert to all platform\nconda convert -f --platform all\n  C:\\Anaconda\\conda-bld\\win-64\\your_package-0.1.1-py27_0.tar.bz2  4.  Upload packages to Anaconda  anaconda login\nanaconda upload linux-32/your_package.tar.bz2\nanaconda upload linux-64/your_package.tar.bz2\nanaconda upload win-32/your_package.tar.bz2\nanaconda upload win-64/your_package.tar.bz2", 
            "title": "Step 4/4: Conda 2"
        }, 
        {
            "location": "/module/#create-private-module", 
            "text": "", 
            "title": "Create Private Module"
        }, 
        {
            "location": "/module/#step-1-make-your-module-1", 
            "text": "1.1   pip install cookiecutter  1.2   cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git  1.3  Fill all necessary information  full_name [Audrey Roy Greenfeld]:\nemail [aroy@alum.mit.edu]:\ngithub_username [audreyr]:\nproject_name [Python Boilerplate]:\nproject_slug []:\nproject_short_description:\nrelease_date []:\npypi_username []:\nyear [2016]:\nversion [0.1.0]:\nuse_pypi_deployment_with_travis [y]:", 
            "title": "Step 1: Make your module 1"
        }, 
        {
            "location": "/module/#step-2-build-your-module", 
            "text": "Change your  MANIFEST.in  recursive-include project_folder *  Build your module with setup.py  cd your_project_folder\n\n# build local\npython setup.py build  It will create a new folder in  $PYTHON_HOME/Lib/sites-packages/your_project_name-0.1.0-py2.7.egg\n\n# build distribution\npython setup.py sdist  It will create a zip file in $PROJECT_FOLDER/dist", 
            "title": "Step 2: Build your module"
        }, 
        {
            "location": "/module/#step-3-usage-your-module", 
            "text": "In the same machine  import your_project_name  In other machine", 
            "title": "Step 3: Usage your module"
        }, 
        {
            "location": "/module/#python-build-install-local-package-with-conda", 
            "text": "Here is a step by step tutorial about building a local module package   install it from a custom channel  1", 
            "title": "Python: Build &amp; Install Local Package with Conda"
        }, 
        {
            "location": "/module/#step-1-make-a-setup-folder-for-your-package-with-cookkiecutter", 
            "text": "on terminal:  \nmkdir build\ncd build\npip install cookiecutter\ncookiecutter https://github.com/audreyr/cookiecutter-pypackage.git  Fill all necessary information  full_name [Audrey Roy Greenfeld]:\nemail [aroy@alum.mit.edu]:\ngithub_username [audreyr]:\nproject_name [Python Boilerplate]:\nproject_slug []:\nproject_short_description:\nrelease_date []:\npypi_username []:\nyear [2016]:\nversion [0.1.0]:\nuse_pypi_deployment_with_travis [y]:  It will create a directory  |- LICENSE\n|- README.md\n|- TODO.md\n|- docs\n|   |-- conf.py\n|   |-- generated\n|   |-- index.rst\n|   |-- installation.rst\n|   |-- modules.rst\n|   |-- quickstart.rst\n|   |-- sandman.rst\n|- requirements.txt\n|- your_package\n|   |-- __init__.py\n|   |-- your_package.py\n|   |-- test\n|       |-- models.py\n|       |-- test_your_package.py\n|- setup.py  Copy your real package into directory above   replace the package has been generated by cookkiecutter  Add this line to  MANIFEST.in  recursive-include project_folder *", 
            "title": "Step 1: Make a setup folder for your package with cookkiecutter"
        }, 
        {
            "location": "/module/#step-2-build-conda-package", 
            "text": "mkdir conda\ncd conda\nmkdir channel\ngit clone https://github.com/hunguyen1702/condaBuildLocalTemplate.git\nmv condaBuildLocalTemplate your_package_name #Which ones you have filled in `project_name` above\ncd your_package_name\nrm -rf .git README.md", 
            "title": "Step 2: Build conda package"
        }, 
        {
            "location": "/module/#edit-the-file-metayaml-with-the-instruction-inside-it", 
            "text": "cd ..\nconda build your_package_name", 
            "title": "Edit the file meta.yaml with the instruction inside it"
        }, 
        {
            "location": "/module/#step-3-create-custom-channel-and-install-from-local-package", 
            "text": "Create a channel directory  cd channel  Convert your_package you've built to all platform  conda convert --platform all ~/anaconda/conda-bld/linux-64/your_package_0.1.0-py27_0.tar.bz2  and this will create:  channel/\nlinux-64/\n   package-1.0-0.tar.bz2\nlinux-32/\n   package-1.0-0.tar.bz2\nosx-64/\n   package-1.0-0.tar.bz2\nwin-64/\n   package-1.0-0.tar.bz2\nwin-32/\n   package-1.0-0.tar.bz2  Register your package to your new channel  cd ..\nconda index channel/linux-64 channel/osx-64 channel/win-64  Veriy your new channel  conda search -c file://path/to/channel/ --override-channels  If you see  your_package 's appearance, so it's worked  After that if you want to install that package from local, run this command:  \nconda install --use-local your_package  and when you want to create environment with local package from file, you just have export environment to  .yml  file and add this  channels  section before the  dependencies  section:  \nchannels:\n- file://path/to/your/channel/      Open Sourcing a Python Project the Right Way    Building conda packages with conda skeleton    How to submit a package to PyPI", 
            "title": "Step 3: Create custom channel and install from local package"
        }, 
        {
            "location": "/production/", 
            "text": "Production with \ndocker\n\n\nBase Image: \nmagizbox/conda2.7/\n\n\nDocker Folder\n\n\nyour_app/\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 run.sh\n\n\n\n\nDockerfile\n\n\nFROM magizbox/conda2.7:4.0\n\nADD ./app /app\nADD ./run.sh /run.sh\n\nRUN conda env create -f environment.yml\n\n\n\n\nrun.sh\n\n\nsource activate your_environment\n\ncd /app\n\npython main.py\n\n\n\n\nCompose\n\n\n service:\n  build: ./service-app\n  command: 'bash run.sh'\n\n\n\n\nNote: an other python conda with lower version (such as 3.5), will occur error when install requests package", 
            "title": "Production"
        }, 
        {
            "location": "/production/#production-with-docker", 
            "text": "Base Image:  magizbox/conda2.7/  Docker Folder  your_app/\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 run.sh  Dockerfile  FROM magizbox/conda2.7:4.0\n\nADD ./app /app\nADD ./run.sh /run.sh\n\nRUN conda env create -f environment.yml  run.sh  source activate your_environment\n\ncd /app\n\npython main.py  Compose   service:\n  build: ./service-app\n  command: 'bash run.sh'  Note: an other python conda with lower version (such as 3.5), will occur error when install requests package", 
            "title": "Production with docker"
        }
    ]
}